{"version":3,"file":"kinectron.cjs.js","sources":["../src/peer/errors.js","../src/peer/peerConfig.js","../src/peer/ngrokState.js","../src/utils/debug.js","../src/peer/peerConnection.js","../src/utils/imageProcessing.js","../src/streams/streamHandlers.js","../src/index.js","../src/kinectron.js"],"sourcesContent":["/**\r\n * Base class for ngrok-related errors\r\n */\r\nexport class NgrokError extends Error {\r\n  /**\r\n   * @param {string} message - Error message\r\n   * @param {Object} details - Additional error details\r\n   */\r\n  constructor(message, details = {}) {\r\n    super(message);\r\n    this.name = 'NgrokError';\r\n    this.details = details;\r\n    this.timestamp = new Date().toISOString();\r\n    this.troubleshooting = [\r\n      'Verify the ngrok tunnel is running',\r\n      'Check if the ngrok URL is correct',\r\n      'Ensure the Kinectron application is running',\r\n    ];\r\n  }\r\n}\r\n\r\n/**\r\n * Error for ngrok connection failures\r\n */\r\nexport class NgrokConnectionError extends NgrokError {\r\n  constructor(message, details = {}) {\r\n    super(message, {\r\n      ...details,\r\n      type: 'connection_error',\r\n    });\r\n    this.name = 'NgrokConnectionError';\r\n    this.troubleshooting = [\r\n      'Check if the ngrok tunnel is still active',\r\n      'Verify your internet connection',\r\n      'Try restarting the ngrok tunnel',\r\n      'Ensure no firewall is blocking the connection',\r\n    ];\r\n  }\r\n}\r\n\r\n/**\r\n * Error for ngrok connection timeouts\r\n */\r\nexport class NgrokTimeoutError extends NgrokError {\r\n  constructor(message, details = {}) {\r\n    super(message, {\r\n      ...details,\r\n      type: 'timeout_error',\r\n    });\r\n    this.name = 'NgrokTimeoutError';\r\n    this.troubleshooting = [\r\n      'The connection attempt timed out',\r\n      'Check your internet connection speed',\r\n      'Verify the Kinectron server is running',\r\n      'Try increasing the connection timeout',\r\n    ];\r\n  }\r\n}\r\n\r\n/**\r\n * Error for invalid ngrok configuration or URLs\r\n */\r\nexport class NgrokValidationError extends NgrokError {\r\n  constructor(message, details = {}) {\r\n    super(message, {\r\n      ...details,\r\n      type: 'validation_error',\r\n    });\r\n    this.name = 'NgrokValidationError';\r\n    this.troubleshooting = [\r\n      'Ensure the URL includes \"ngrok-free.app\"',\r\n      'Copy the URL directly from the Kinectron application',\r\n      'Make sure to include the full domain name',\r\n    ];\r\n  }\r\n}\r\n\r\n/**\r\n * Error codes and their descriptions\r\n */\r\nexport const NgrokErrorCodes = {\r\n  INVALID_URL: {\r\n    code: 'NGROK_001',\r\n    message: 'Invalid ngrok URL format',\r\n  },\r\n  CONNECTION_FAILED: {\r\n    code: 'NGROK_002',\r\n    message: 'Failed to establish ngrok connection',\r\n  },\r\n  CONNECTION_TIMEOUT: {\r\n    code: 'NGROK_003',\r\n    message: 'Connection attempt timed out',\r\n  },\r\n  TUNNEL_CLOSED: {\r\n    code: 'NGROK_004',\r\n    message: 'Ngrok tunnel was closed',\r\n  },\r\n  SERVER_UNREACHABLE: {\r\n    code: 'NGROK_005',\r\n    message: 'Unable to reach Kinectron server',\r\n  },\r\n};\r\n","import { NgrokValidationError, NgrokErrorCodes } from './errors.js';\r\n\r\n/**\r\n * Validates a ngrok URL format\r\n * @param {string} url - The URL to validate\r\n * @throws {NgrokValidationError} If URL is invalid\r\n */\r\nfunction validateNgrokUrl(url) {\r\n  if (!url.includes('ngrok-free.app')) {\r\n    throw new NgrokValidationError(\r\n      NgrokErrorCodes.INVALID_URL.message,\r\n      {\r\n        code: NgrokErrorCodes.INVALID_URL.code,\r\n        url,\r\n        reason: 'URL must include ngrok-free.app domain',\r\n      },\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef {Object} PeerNetworkConfig\r\n * @property {string} host - The host address for the peer server\r\n * @property {number|string} port - The port number for the peer server\r\n * @property {string} path - The path for the peer server\r\n * @property {boolean} [secure] - Whether to use secure connection\r\n * @property {string} [role] - Role identifier for the connection (e.g., 'modern-test', 'legacy-test')\r\n */\r\n\r\n/**\r\n * Default peer network configuration\r\n * @type {PeerNetworkConfig}\r\n */\r\nexport const DEFAULT_PEER_CONFIG = {\r\n  host: '127.0.0.1',\r\n  port: 9001,\r\n  path: '/',\r\n  secure: false,\r\n  debug: 3, // Enable detailed logging\r\n  role: 'default', // Default role identifier\r\n  // For local connections, we don't need STUN/TURN servers\r\n  // This matches the original kinectron implementation\r\n  config: {\r\n    iceServers: [],\r\n    sdpSemantics: 'unified-plan',\r\n  },\r\n};\r\n\r\n/**\r\n * Default peer ID for the Kinectron server\r\n * @type {string}\r\n */\r\nexport const DEFAULT_PEER_ID = 'kinectron';\r\n\r\n/**\r\n * Validates and processes peer network configuration\r\n * @param {Object} config - User provided network configuration\r\n * @returns {PeerNetworkConfig} Processed network configuration\r\n */\r\nexport function processPeerConfig(config) {\r\n  if (!config) return DEFAULT_PEER_CONFIG;\r\n\r\n  // Handle ngrok addresses\r\n  if (typeof config === 'string' && config.includes('ngrok')) {\r\n    try {\r\n      validateNgrokUrl(config);\r\n      return {\r\n        host: config,\r\n        port: '443',\r\n        path: '/',\r\n        secure: true,\r\n        debug: 3,\r\n        config: {\r\n          iceServers: [],\r\n          sdpSemantics: 'unified-plan',\r\n        },\r\n      };\r\n    } catch (error) {\r\n      // Add connection context to validation errors\r\n      if (error instanceof NgrokValidationError) {\r\n        error.details.context = 'peer_config_validation';\r\n        error.details.timestamp = new Date().toISOString();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Handle IP addresses or custom configs\r\n  if (typeof config === 'string') {\r\n    return {\r\n      ...DEFAULT_PEER_CONFIG,\r\n      host: config,\r\n    };\r\n  }\r\n\r\n  // Handle full custom config objects\r\n  return {\r\n    ...DEFAULT_PEER_CONFIG,\r\n    ...config,\r\n  };\r\n}\r\n","/**\r\n * Represents a client-side ngrok connection state error\r\n */\r\nexport class NgrokClientError extends Error {\r\n  constructor(message, details = {}) {\r\n    super(message);\r\n    this.name = 'NgrokClientError';\r\n    this.details = details;\r\n    this.timestamp = new Date().toISOString();\r\n    this.troubleshooting = [\r\n      'Check if the ngrok tunnel is running',\r\n      'Verify the URL is correct',\r\n      'Ensure the Kinectron application is running',\r\n    ];\r\n  }\r\n}\r\n\r\n/**\r\n * Manages client-side ngrok connection state and metrics\r\n */\r\nexport class NgrokClientState {\r\n  /**\r\n   * Available connection states\r\n   */\r\n  static STATES = {\r\n    DISCONNECTED: 'disconnected',\r\n    VALIDATING: 'validating',\r\n    CONNECTING: 'connecting',\r\n    CONNECTED: 'connected',\r\n    RECONNECTING: 'reconnecting',\r\n    ERROR: 'error',\r\n  };\r\n\r\n  /**\r\n   * Valid state transitions\r\n   */\r\n  static VALID_TRANSITIONS = {\r\n    [NgrokClientState.STATES.DISCONNECTED]: [\r\n      NgrokClientState.STATES.VALIDATING,\r\n      NgrokClientState.STATES.CONNECTING,\r\n    ],\r\n    [NgrokClientState.STATES.VALIDATING]: [\r\n      NgrokClientState.STATES.CONNECTING,\r\n      NgrokClientState.STATES.ERROR,\r\n    ],\r\n    [NgrokClientState.STATES.CONNECTING]: [\r\n      NgrokClientState.STATES.CONNECTED,\r\n      NgrokClientState.STATES.RECONNECTING,\r\n      NgrokClientState.STATES.ERROR,\r\n      NgrokClientState.STATES.CONNECTING, // Allow re-entering connecting state\r\n    ],\r\n    [NgrokClientState.STATES.CONNECTED]: [\r\n      NgrokClientState.STATES.DISCONNECTED,\r\n      NgrokClientState.STATES.RECONNECTING,\r\n      NgrokClientState.STATES.ERROR,\r\n      NgrokClientState.STATES.CONNECTED, // Allow self-transition to refresh state\r\n    ],\r\n    [NgrokClientState.STATES.RECONNECTING]: [\r\n      NgrokClientState.STATES.CONNECTED,\r\n      NgrokClientState.STATES.CONNECTING,\r\n      NgrokClientState.STATES.ERROR,\r\n    ],\r\n    [NgrokClientState.STATES.ERROR]: [\r\n      NgrokClientState.STATES.DISCONNECTED,\r\n      NgrokClientState.STATES.CONNECTING,\r\n    ],\r\n  };\r\n\r\n  constructor() {\r\n    this.currentState = null; // Start with no state\r\n    this.metadata = {\r\n      url: null,\r\n      startTime: null,\r\n      lastStateChange: new Date(),\r\n      errorHistory: [],\r\n      metrics: {\r\n        latency: {\r\n          current: 0,\r\n          average: 0,\r\n          samples: [],\r\n        },\r\n        connectionQuality: 'unknown',\r\n        reconnects: {\r\n          count: 0,\r\n          lastAttempt: null,\r\n        },\r\n        errors: {\r\n          total: 0,\r\n          byType: {},\r\n        },\r\n      },\r\n    };\r\n\r\n    // Event handlers\r\n    this.handlers = {\r\n      stateChange: new Set(),\r\n      error: new Set(),\r\n      metrics: new Set(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Add event listener\r\n   * @param {string} event - Event type\r\n   * @param {Function} handler - Event handler\r\n   */\r\n  on(event, handler) {\r\n    if (this.handlers[event]) {\r\n      this.handlers[event].add(handler);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove event listener\r\n   * @param {string} event - Event type\r\n   * @param {Function} handler - Event handler\r\n   */\r\n  off(event, handler) {\r\n    if (this.handlers[event]) {\r\n      this.handlers[event].delete(handler);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Emit event to handlers\r\n   * @private\r\n   * @param {string} event - Event type\r\n   * @param {*} data - Event data\r\n   */\r\n  _emit(event, data) {\r\n    if (this.handlers[event]) {\r\n      this.handlers[event].forEach((handler) => handler(data));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current state\r\n   * @returns {string} Current state\r\n   */\r\n  getState() {\r\n    return this.currentState;\r\n  }\r\n\r\n  /**\r\n   * Get state metadata\r\n   * @returns {Object} State metadata\r\n   */\r\n  getMetadata() {\r\n    return {\r\n      ...this.metadata,\r\n      currentState: this.currentState,\r\n      uptime: this._calculateUptime(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update connection metrics\r\n   * @param {Object} metrics - New metrics\r\n   */\r\n  updateMetrics(metrics) {\r\n    // Update latency\r\n    if (metrics.latency !== undefined) {\r\n      this.metadata.metrics.latency.current = metrics.latency;\r\n      this.metadata.metrics.latency.samples.push({\r\n        value: metrics.latency,\r\n        timestamp: new Date(),\r\n      });\r\n\r\n      // Keep last 10 samples\r\n      if (this.metadata.metrics.latency.samples.length > 10) {\r\n        this.metadata.metrics.latency.samples.shift();\r\n      }\r\n\r\n      // Calculate average\r\n      this.metadata.metrics.latency.average =\r\n        this.metadata.metrics.latency.samples.reduce(\r\n          (sum, sample) => sum + sample.value,\r\n          0,\r\n        ) / this.metadata.metrics.latency.samples.length;\r\n    }\r\n\r\n    // Update connection quality based on metrics\r\n    this._updateConnectionQuality();\r\n\r\n    // Emit metrics update\r\n    this._emit('metrics', this.metadata.metrics);\r\n  }\r\n\r\n  /**\r\n   * Set connection state\r\n   * @param {string} newState - New state\r\n   * @param {Object} details - Transition details\r\n   * @throws {NgrokClientError} If transition is invalid\r\n   */\r\n  setState(newState, details = {}) {\r\n    if (!this._isValidTransition(newState)) {\r\n      throw new NgrokClientError(\r\n        `Invalid state transition from ${this.currentState} to ${newState}`,\r\n        {\r\n          from: this.currentState,\r\n          to: newState,\r\n          details,\r\n        },\r\n      );\r\n    }\r\n\r\n    const oldState = this.currentState;\r\n    this.currentState = newState;\r\n    this.metadata.lastStateChange = new Date();\r\n\r\n    // Update metadata based on state\r\n    if (newState === NgrokClientState.STATES.CONNECTED) {\r\n      if (!this.metadata.startTime) {\r\n        this.metadata.startTime = new Date();\r\n      }\r\n    } else if (newState === NgrokClientState.STATES.RECONNECTING) {\r\n      this.metadata.metrics.reconnects.count++;\r\n      this.metadata.metrics.reconnects.lastAttempt = new Date();\r\n    }\r\n\r\n    // Emit state change event\r\n    this._emit('stateChange', {\r\n      from: oldState,\r\n      to: newState,\r\n      timestamp: this.metadata.lastStateChange,\r\n      details,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Record an error\r\n   * @param {Error} error - Error to record\r\n   * @param {Object} context - Error context\r\n   */\r\n  recordError(error, context = {}) {\r\n    const errorRecord = {\r\n      name: error.name,\r\n      message: error.message,\r\n      timestamp: new Date(),\r\n      context,\r\n      state: this.currentState,\r\n    };\r\n\r\n    // Add to error history (keep last 10)\r\n    this.metadata.errorHistory.unshift(errorRecord);\r\n    if (this.metadata.errorHistory.length > 10) {\r\n      this.metadata.errorHistory.pop();\r\n    }\r\n\r\n    // Update error metrics\r\n    this.metadata.metrics.errors.total++;\r\n    this.metadata.metrics.errors.byType[error.name] =\r\n      (this.metadata.metrics.errors.byType[error.name] || 0) + 1;\r\n\r\n    // Emit error event\r\n    this._emit('error', errorRecord);\r\n  }\r\n\r\n  /**\r\n   * Reset state to initial values\r\n   */\r\n  reset() {\r\n    this.currentState = null;\r\n    this.metadata = {\r\n      url: null,\r\n      startTime: null,\r\n      lastStateChange: new Date(),\r\n      errorHistory: [],\r\n      metrics: {\r\n        latency: {\r\n          current: 0,\r\n          average: 0,\r\n          samples: [],\r\n        },\r\n        connectionQuality: 'unknown',\r\n        reconnects: {\r\n          count: 0,\r\n          lastAttempt: null,\r\n        },\r\n        errors: {\r\n          total: 0,\r\n          byType: {},\r\n        },\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate connection uptime\r\n   * @private\r\n   * @returns {number} Uptime in milliseconds\r\n   */\r\n  _calculateUptime() {\r\n    if (\r\n      !this.metadata.startTime ||\r\n      this.currentState !== NgrokClientState.STATES.CONNECTED\r\n    ) {\r\n      return 0;\r\n    }\r\n    return Date.now() - this.metadata.startTime.getTime();\r\n  }\r\n\r\n  /**\r\n   * Update connection quality based on metrics\r\n   * @private\r\n   */\r\n  _updateConnectionQuality() {\r\n    const avgLatency = this.metadata.metrics.latency.average;\r\n    const recentErrors = this.metadata.errorHistory.filter(\r\n      (e) => Date.now() - new Date(e.timestamp).getTime() < 60000, // Last minute\r\n    ).length;\r\n\r\n    if (recentErrors > 2) {\r\n      this.metadata.metrics.connectionQuality = 'poor';\r\n    } else if (avgLatency > 1000) {\r\n      // 1 second\r\n      this.metadata.metrics.connectionQuality = 'unstable';\r\n    } else if (avgLatency > 500) {\r\n      // 500ms\r\n      this.metadata.metrics.connectionQuality = 'fair';\r\n    } else {\r\n      this.metadata.metrics.connectionQuality = 'good';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if state transition is valid\r\n   * @private\r\n   * @param {string} newState - State to transition to\r\n   * @returns {boolean} Whether transition is valid\r\n   */\r\n  _isValidTransition(newState) {\r\n    // Allow any initial state transition\r\n    if (this.currentState === null) {\r\n      return true;\r\n    }\r\n    const validNextStates =\r\n      NgrokClientState.VALID_TRANSITIONS[this.currentState];\r\n    return validNextStates && validNextStates.includes(newState);\r\n  }\r\n}\r\n","/**\r\n * Debug configuration for Kinectron client\r\n * Controls logging output for different components\r\n *\r\n * @namespace DEBUG\r\n */\r\n\r\nexport const DEBUG = {\r\n  /**\r\n   * Master switch for frame-related logging\r\n   * Controls logs about frame processing, transmission, and visualization\r\n   * @type {boolean}\r\n   */\r\n  FRAMES: false,\r\n\r\n  /**\r\n   * Master switch for handler-related logging\r\n   * Controls logs about stream handlers and event processing\r\n   * @type {boolean}\r\n   */\r\n  HANDLERS: false,\r\n\r\n  /**\r\n   * Master switch for peer connection logs\r\n   * Controls logs about WebRTC connections, state changes, and data channels\r\n   * @type {boolean}\r\n   */\r\n  PEER: false,\r\n\r\n  /**\r\n   * For performance-related logs\r\n   * Controls logs about timing, frame rates, and processing efficiency\r\n   * @type {boolean}\r\n   */\r\n  PERFORMANCE: false,\r\n\r\n  /**\r\n   * For data integrity logs\r\n   * Controls logs about data validation, transformation, and verification\r\n   * @type {boolean}\r\n   */\r\n  DATA: false,\r\n\r\n  /**\r\n   * For network-related logs\r\n   * Controls logs about network status, bandwidth, and transmission\r\n   * @type {boolean}\r\n   */\r\n  NETWORK: false,\r\n\r\n  /**\r\n   * Enable all debug flags\r\n   * Turns on all logging categories for comprehensive debugging\r\n   * @returns {void}\r\n   * @example\r\n   * // Enable all debug logs\r\n   * DEBUG.enableAll();\r\n   */\r\n  enableAll: function () {\r\n    Object.keys(this).forEach((key) => {\r\n      if (typeof this[key] === 'boolean') this[key] = true;\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Disable all debug flags\r\n   * Turns off all logging categories for clean console output\r\n   * @returns {void}\r\n   * @example\r\n   * // Disable all debug logs\r\n   * DEBUG.disableAll();\r\n   */\r\n  disableAll: function () {\r\n    Object.keys(this).forEach((key) => {\r\n      if (typeof this[key] === 'boolean') this[key] = false;\r\n    });\r\n  },\r\n};\r\n\r\n/**\r\n * Logging utility functions that check debug flags\r\n * Provides category-specific logging with automatic flag checking\r\n *\r\n * @namespace log\r\n */\r\nexport const log = {\r\n  /**\r\n   * Log error messages (always visible regardless of debug flags)\r\n   * Use for critical errors that should always be visible\r\n   *\r\n   * @param {string} message - The error message\r\n   * @param {...any} args - Additional arguments to log\r\n   * @returns {void}\r\n   * @example\r\n   * log.error('Failed to connect to server:', error);\r\n   */\r\n  error: function (message, ...args) {\r\n    console.error(message, ...args);\r\n  },\r\n\r\n  /**\r\n   * Log warning messages (always visible regardless of debug flags)\r\n   * Use for potential issues that should always be visible\r\n   *\r\n   * @param {string} message - The warning message\r\n   * @param {...any} args - Additional arguments to log\r\n   * @returns {void}\r\n   * @example\r\n   * log.warn('Connection attempt timed out, retrying...');\r\n   */\r\n  warn: function (message, ...args) {\r\n    console.warn(message, ...args);\r\n  },\r\n\r\n  /**\r\n   * Log informational messages (always visible regardless of debug flags)\r\n   * Use for important status updates that should always be visible\r\n   *\r\n   * @param {string} message - The info message\r\n   * @param {...any} args - Additional arguments to log\r\n   * @returns {void}\r\n   * @example\r\n   * log.info('Connected to Kinectron server');\r\n   */\r\n  info: function (message, ...args) {\r\n    console.log(message, ...args);\r\n  },\r\n\r\n  /**\r\n   * Log debug messages for a specific category\r\n   * Only logs if the specified debug flag is enabled\r\n   *\r\n   * @param {string} flag - The debug flag to check\r\n   * @param {string} message - The debug message\r\n   * @param {...any} args - Additional arguments to log\r\n   * @returns {void}\r\n   * @example\r\n   * log.debug('PERFORMANCE', 'Frame processing took:', processingTime, 'ms');\r\n   */\r\n  debug: function (flag, message, ...args) {\r\n    if (DEBUG[flag]) {\r\n      console.debug(`[${flag}] ${message}`, ...args);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Log frame-related messages\r\n   * Only logs if the FRAMES debug flag is enabled\r\n   *\r\n   * @param {string} message - The frame-related message\r\n   * @param {...any} args - Additional arguments to log\r\n   * @returns {void}\r\n   * @example\r\n   * log.frame('Received color frame with dimensions:', width, 'x', height);\r\n   */\r\n  frame: function (message, ...args) {\r\n    if (DEBUG.FRAMES) {\r\n      console.debug(`[FRAMES] ${message}`, ...args);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Log handler-related messages\r\n   * Only logs if the HANDLERS debug flag is enabled\r\n   *\r\n   * @param {string} message - The handler-related message\r\n   * @param {...any} args - Additional arguments to log\r\n   * @returns {void}\r\n   * @example\r\n   * log.handler('Creating body handler with callback');\r\n   */\r\n  handler: function (message, ...args) {\r\n    if (DEBUG.HANDLERS) {\r\n      console.debug(`[HANDLERS] ${message}`, ...args);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Log peer connection-related messages\r\n   * Only logs if the PEER debug flag is enabled\r\n   *\r\n   * @param {string} message - The peer-related message\r\n   * @param {...any} args - Additional arguments to log\r\n   * @returns {void}\r\n   * @example\r\n   * log.peer('Connected to peer:', peerId);\r\n   */\r\n  peer: function (message, ...args) {\r\n    if (DEBUG.PEER) {\r\n      console.debug(`[PEER] ${message}`, ...args);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Log performance-related messages\r\n   * Only logs if the PERFORMANCE debug flag is enabled\r\n   *\r\n   * @param {string} message - The performance-related message\r\n   * @param {...any} args - Additional arguments to log\r\n   * @returns {void}\r\n   * @example\r\n   * log.performance('Frame rate:', frameRate, 'fps');\r\n   */\r\n  performance: function (message, ...args) {\r\n    if (DEBUG.PERFORMANCE) {\r\n      console.debug(`[PERFORMANCE] ${message}`, ...args);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Log data integrity-related messages\r\n   * Only logs if the DATA debug flag is enabled\r\n   *\r\n   * @param {string} message - The data-related message\r\n   * @param {...any} args - Additional arguments to log\r\n   * @returns {void}\r\n   * @example\r\n   * log.data('Unpacking raw depth data with dimensions:', width, 'x', height);\r\n   */\r\n  data: function (message, ...args) {\r\n    if (DEBUG.DATA) {\r\n      console.debug(`[DATA] ${message}`, ...args);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Log network-related messages\r\n   * Only logs if the NETWORK debug flag is enabled\r\n   *\r\n   * @param {string} message - The network-related message\r\n   * @param {...any} args - Additional arguments to log\r\n   * @returns {void}\r\n   * @example\r\n   * log.network('Data channel buffer size:', bufferAmount, 'bytes');\r\n   */\r\n  network: function (message, ...args) {\r\n    if (DEBUG.NETWORK) {\r\n      console.debug(`[NETWORK] ${message}`, ...args);\r\n    }\r\n  },\r\n};\r\n","import Peer from 'peerjs';\r\nimport { DEFAULT_PEER_ID, processPeerConfig } from './peerConfig.js';\r\nimport { NgrokClientState, NgrokClientError } from './ngrokState.js';\r\nimport { DEBUG } from '../utils/debug.js';\r\n\r\n/**\r\n * @typedef {import('./peerConfig.js').PeerNetworkConfig} PeerNetworkConfig\r\n */\r\n\r\n/**\r\n * Enhanced peer-to-peer connection handler with improved reliability\r\n */\r\nexport class PeerConnection {\r\n  /**\r\n   * @param {string|PeerNetworkConfig} [networkConfig] - Network configuration or host address\r\n   * @param {string} [peerId] - ID of the peer to connect to\r\n   */\r\n  constructor(networkConfig, peerId) {\r\n    /** @private */\r\n    this.peer = null;\r\n    /** @private */\r\n    this.connection = null;\r\n    /** @private */\r\n    this.targetPeerId = peerId || DEFAULT_PEER_ID;\r\n    /** @private */\r\n    this.config = processPeerConfig(networkConfig);\r\n    /** @private */\r\n    this.messageHandlers = new Map();\r\n    /** @private */\r\n    this.messageQueue = [];\r\n    /** @private */\r\n    this.maxQueueSize = 100;\r\n    /** @private */\r\n    this.lastPingTime = 0;\r\n    /** @private */\r\n    this.pingInterval = null;\r\n    /** @private */\r\n    this.healthCheckInterval = null;\r\n    /** @private */\r\n    this.clientId = this.generateClientId();\r\n    /** @private */\r\n    this.state = new NgrokClientState();\r\n\r\n    // Forward state events to message handlers\r\n    this.state.on('stateChange', (data) => {\r\n      const handler = this.messageHandlers.get('stateChange');\r\n      if (handler) handler(data);\r\n    });\r\n\r\n    this.state.on('error', (data) => {\r\n      const handler = this.messageHandlers.get('error');\r\n      if (handler) handler(data);\r\n    });\r\n\r\n    this.state.on('metrics', (data) => {\r\n      const handler = this.messageHandlers.get('metrics');\r\n      if (handler) handler(data);\r\n    });\r\n\r\n    this.initialize();\r\n  }\r\n\r\n  /**\r\n   * Generate a consistent client ID\r\n   * @private\r\n   * @returns {string} Client ID\r\n   */\r\n  generateClientId() {\r\n    // Generate unique ID for each instance\r\n    const timestamp = Date.now().toString(36);\r\n    const random = Math.random().toString(36).substr(2, 5);\r\n    const prefix = this.config.host?.includes('ngrok')\r\n      ? 'ngrok'\r\n      : 'local';\r\n    const role = this.config.role || 'default';\r\n    return `${prefix}-${role}-${timestamp}-${random}`;\r\n  }\r\n\r\n  /**\r\n   * Get current connection state\r\n   * @returns {Object} Current state information\r\n   */\r\n  getState() {\r\n    return this.state.getMetadata();\r\n  }\r\n\r\n  /**\r\n   * Initialize the peer connection with enhanced reliability\r\n   * @private\r\n   */\r\n  initialize() {\r\n    try {\r\n      if (this.peer) {\r\n        console.warn('Peer already initialized');\r\n        return;\r\n      }\r\n\r\n      if (DEBUG.PEER) {\r\n        console.log('Initializing peer with config:', this.config);\r\n      }\r\n\r\n      // Check if this is an ngrok connection\r\n      const isNgrok =\r\n        typeof this.config.host === 'string' &&\r\n        this.config.host.includes('ngrok');\r\n\r\n      if (isNgrok) {\r\n        // Set state to validating for ngrok connections\r\n        this.state.setState(NgrokClientState.STATES.VALIDATING);\r\n\r\n        // Validate ngrok URL format\r\n        if (!this.config.host.includes('ngrok-free.app')) {\r\n          throw new NgrokClientError('Invalid ngrok URL format', {\r\n            url: this.config.host,\r\n            reason: 'URL must include ngrok-free.app domain',\r\n          });\r\n        }\r\n      }\r\n\r\n      // Create peer instance with consistent ID\r\n      this.peer = new Peer(this.clientId, {\r\n        ...this.config,\r\n        // Basic reliability options\r\n        reliable: true,\r\n        retries: 2,\r\n        timeout: isNgrok ? 5000 : 3000,\r\n        debug: 0, // Reduced from 3 to 0 to suppress verbose logs\r\n      });\r\n\r\n      // Move to connecting state (skip validation for local connections)\r\n      if (!isNgrok) {\r\n        this.state.setState(NgrokClientState.STATES.CONNECTING);\r\n      }\r\n\r\n      this.setupPeerEventHandlers();\r\n      this.startHealthCheck();\r\n    } catch (error) {\r\n      console.error('Peer initialization error:', error);\r\n      this.handleError(error);\r\n      this.state.setState(NgrokClientState.STATES.ERROR, {\r\n        error: error.message,\r\n        context: 'initialization',\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set up event handlers for the peer instance\r\n   * @private\r\n   */\r\n  setupPeerEventHandlers() {\r\n    this.peer.on('open', (id) => {\r\n      if (DEBUG.PEER) {\r\n        console.log('My peer ID is:', id);\r\n      }\r\n      // Already in CONNECTING state, proceed with connection\r\n      this.connect();\r\n    });\r\n\r\n    this.peer.on('error', (error) => {\r\n      console.error('Peer connection error:', error);\r\n\r\n      // Handle ID taken error by generating new ID\r\n      if (error.type === 'unavailable-id') {\r\n        if (DEBUG.PEER) {\r\n          console.log('Client ID taken, generating new ID');\r\n        }\r\n        this.clientId = this.generateClientId();\r\n        this._cleanup(false);\r\n        this.initialize();\r\n        return;\r\n      }\r\n\r\n      this.handleError(error);\r\n\r\n      // Set error state\r\n      this.state.setState(NgrokClientState.STATES.ERROR, {\r\n        error: error.message,\r\n        type: error.type,\r\n      });\r\n\r\n      // Attempt reconnection if appropriate\r\n      if (this.shouldAttemptReconnection(error)) {\r\n        this._handleReconnection(error);\r\n      }\r\n    });\r\n\r\n    this.peer.on('disconnected', () => {\r\n      if (DEBUG.PEER) {\r\n        console.log('Peer disconnected from server');\r\n      }\r\n      this.state.setState(NgrokClientState.STATES.DISCONNECTED, {\r\n        reason: 'peer_disconnected',\r\n      });\r\n      this._handleReconnection({ type: 'disconnected' });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Start health check interval\r\n   * @private\r\n   */\r\n  startHealthCheck() {\r\n    // Clear any existing intervals\r\n    if (this.healthCheckInterval) {\r\n      clearInterval(this.healthCheckInterval);\r\n    }\r\n    if (this.pingInterval) {\r\n      clearInterval(this.pingInterval);\r\n    }\r\n\r\n    // Start health check\r\n    this.healthCheckInterval = setInterval(() => {\r\n      if (\r\n        this.state.getState() === NgrokClientState.STATES.CONNECTED &&\r\n        this.connection\r\n      ) {\r\n        this.checkConnectionHealth();\r\n      }\r\n    }, 10000);\r\n\r\n    // Start ping interval\r\n    this.pingInterval = setInterval(() => {\r\n      if (\r\n        this.state.getState() === NgrokClientState.STATES.CONNECTED &&\r\n        this.connection?.open\r\n      ) {\r\n        this.sendPing();\r\n      }\r\n    }, 5000);\r\n  }\r\n\r\n  /**\r\n   * Check connection health\r\n   * @private\r\n   */\r\n  async checkConnectionHealth() {\r\n    if (!this.connection?.open) {\r\n      console.warn('Connection appears dead, attempting recovery');\r\n      await this.handleConnectionFailure();\r\n      return;\r\n    }\r\n\r\n    // Check last ping time\r\n    const timeSinceLastPing = Date.now() - this.lastPingTime;\r\n    if (timeSinceLastPing > 15000) {\r\n      // No ping response for 15 seconds\r\n      console.warn('No ping response, connection may be dead');\r\n      await this.handleConnectionFailure();\r\n    }\r\n\r\n    // Update connection metrics\r\n    this.state.updateMetrics({\r\n      latency: timeSinceLastPing,\r\n      timestamp: new Date(),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Send ping to peer\r\n   * @private\r\n   */\r\n  sendPing() {\r\n    try {\r\n      this.connection.send({\r\n        event: 'ping',\r\n        data: { timestamp: Date.now() },\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to send ping:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle connection failure\r\n   * @private\r\n   */\r\n  async handleConnectionFailure() {\r\n    if (this.connection) {\r\n      try {\r\n        this.connection.close();\r\n      } catch (error) {\r\n        console.error('Error closing connection:', error);\r\n      }\r\n      this.connection = null;\r\n    }\r\n\r\n    this.state.setState(NgrokClientState.STATES.RECONNECTING, {\r\n      reason: 'connection_failure',\r\n      timestamp: new Date(),\r\n    });\r\n\r\n    await this._handleReconnection({ type: 'connection_failure' });\r\n  }\r\n\r\n  /**\r\n   * Handle errors with enhanced information\r\n   * @private\r\n   * @param {Error} error - The error that occurred\r\n   */\r\n  handleError(error) {\r\n    // Record error in state\r\n    this.state.recordError(error, {\r\n      type: error.type || 'server-error',\r\n      state: this.state.getState(),\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n\r\n    // Forward to message handler\r\n    const handler = this.messageHandlers.get('error');\r\n    if (handler) {\r\n      const errorInfo = {\r\n        status: 'error',\r\n        error: this._getErrorMessage(error),\r\n        details: {\r\n          type: error.type || 'server-error',\r\n          state: this.state.getState(),\r\n          timestamp: new Date().toISOString(),\r\n        },\r\n      };\r\n      handler(errorInfo);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get user-friendly error message\r\n   * @private\r\n   * @param {Error} error - The error object\r\n   * @returns {string} User-friendly error message\r\n   */\r\n  _getErrorMessage(error) {\r\n    const errorMessages = {\r\n      network: 'Network error - Could not connect to peer server',\r\n      'invalid-id':\r\n        'Invalid ID - The peer ID is invalid or already taken',\r\n      'unavailable-id':\r\n        'ID Unavailable - The peer ID is already taken',\r\n      'browser-incompatible':\r\n        'Browser Incompatible - WebRTC is not supported',\r\n      'connection-failure':\r\n        'Connection failed - Unable to establish or maintain connection',\r\n      disconnected: 'Disconnected - Lost connection to peer server',\r\n    };\r\n\r\n    return (\r\n      errorMessages[error.type] ||\r\n      error.message ||\r\n      'Peer connection error'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Determine if reconnection should be attempted\r\n   * @private\r\n   * @param {Error} error - The error that occurred\r\n   * @returns {boolean} Whether to attempt reconnection\r\n   */\r\n  shouldAttemptReconnection(error) {\r\n    // Don't reconnect for certain error types\r\n    const fatalErrors = [\r\n      'browser-incompatible',\r\n      'invalid-id',\r\n      'invalid-key',\r\n    ];\r\n    if (fatalErrors.includes(error.type)) {\r\n      return false;\r\n    }\r\n\r\n    return this.state.getMetadata().metrics.reconnects.count < 3;\r\n  }\r\n\r\n  /**\r\n   * Set connection timeout with enhanced retry logic\r\n   * @private\r\n   */\r\n  _setConnectionTimeout() {\r\n    const timeoutDuration = 15000; // 15 second timeout for ngrok connections\r\n\r\n    setTimeout(() => {\r\n      if (\r\n        this.state.getState() !== NgrokClientState.STATES.CONNECTED\r\n      ) {\r\n        if (DEBUG.PEER) {\r\n          console.log('Connection attempt timed out');\r\n        }\r\n\r\n        if (this.shouldAttemptReconnection({ type: 'timeout' })) {\r\n          this._handleReconnection({ type: 'timeout' });\r\n        } else {\r\n          this.handleError({\r\n            type: 'timeout',\r\n            message: 'Connection timeout - Max attempts reached',\r\n          });\r\n        }\r\n      }\r\n    }, timeoutDuration);\r\n  }\r\n\r\n  /**\r\n   * Handle reconnection logic with improved retry strategy\r\n   * @private\r\n   * @param {Error} error - The error that triggered reconnection\r\n   */\r\n  async _handleReconnection(error) {\r\n    // Update state to reconnecting\r\n    this.state.setState(NgrokClientState.STATES.RECONNECTING, {\r\n      error: error.message,\r\n      attempt: this.state.getMetadata().metrics.reconnects.count + 1,\r\n    });\r\n\r\n    // Use exponential backoff with jitter\r\n    const baseDelay = Math.min(\r\n      2000 *\r\n        Math.pow(\r\n          1.5,\r\n          this.state.getMetadata().metrics.reconnects.count,\r\n        ),\r\n      15000,\r\n    );\r\n    const jitter = baseDelay * 0.2 * (Math.random() * 2 - 1);\r\n    const delay = Math.max(2000, baseDelay + jitter);\r\n\r\n    if (DEBUG.PEER) {\r\n      console.log(\r\n        `Attempting reconnection ${\r\n          this.state.getMetadata().metrics.reconnects.count + 1\r\n        } of 3 in ${Math.round(delay)}ms`,\r\n      );\r\n    }\r\n\r\n    // Wait for delay\r\n    await new Promise((resolve) => setTimeout(resolve, delay));\r\n\r\n    if (\r\n      this.state.getState() === NgrokClientState.STATES.RECONNECTING\r\n    ) {\r\n      if (DEBUG.PEER) {\r\n        console.log('Attempting to reconnect...');\r\n      }\r\n\r\n      // Clean up existing resources\r\n      await this._cleanup(false);\r\n\r\n      // Only try to reconnect if we haven't exceeded max attempts\r\n      if (this.shouldAttemptReconnection(error)) {\r\n        // Move back to connecting state\r\n        this.state.setState(NgrokClientState.STATES.CONNECTING);\r\n        this.initialize();\r\n      } else {\r\n        if (DEBUG.PEER) {\r\n          console.log('Max reconnection attempts reached');\r\n        }\r\n        this.state.setState(NgrokClientState.STATES.ERROR, {\r\n          error: 'Maximum reconnection attempts reached',\r\n          type: 'max_retries',\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up resources\r\n   * @private\r\n   * @param {boolean} [isClosing=true] - Whether this is a final cleanup\r\n   */\r\n  async _cleanup(isClosing = true) {\r\n    // Clean up existing peer\r\n    if (this.peer) {\r\n      this.peer.destroy();\r\n      this.peer = null;\r\n    }\r\n\r\n    // Clean up existing connection\r\n    if (this.connection) {\r\n      this.connection.close();\r\n      this.connection = null;\r\n    }\r\n\r\n    // Clear intervals if doing final cleanup\r\n    if (isClosing) {\r\n      if (this.healthCheckInterval) {\r\n        clearInterval(this.healthCheckInterval);\r\n        this.healthCheckInterval = null;\r\n      }\r\n      if (this.pingInterval) {\r\n        clearInterval(this.pingInterval);\r\n        this.pingInterval = null;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Connect to target peer with enhanced reliability\r\n   */\r\n  connect() {\r\n    try {\r\n      // Check if we already have a connection\r\n      if (this.peer.connections[this.targetPeerId]?.length > 0) {\r\n        const existingConn =\r\n          this.peer.connections[this.targetPeerId][0];\r\n        if (existingConn.open) {\r\n          if (DEBUG.PEER) {\r\n            console.log('Reusing existing connection');\r\n          }\r\n          this.connection = existingConn;\r\n          this.setupConnectionHandlers();\r\n          return;\r\n        }\r\n      }\r\n\r\n      // Create new connection\r\n      if (DEBUG.PEER) {\r\n        console.log('Creating new connection to:', this.targetPeerId);\r\n      }\r\n      this.connection = this.peer.connect(this.targetPeerId, {\r\n        reliable: true,\r\n        serialization: 'binary', // Explicitly set to binary\r\n      });\r\n\r\n      this.setupConnectionHandlers();\r\n      this._setConnectionTimeout();\r\n    } catch (error) {\r\n      console.error('Error establishing connection:', error);\r\n      this._handleReconnection(error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set up handlers for the peer connection\r\n   * @private\r\n   */\r\n  setupConnectionHandlers() {\r\n    this.connection.on('open', () => {\r\n      if (DEBUG.PEER) {\r\n        console.log('Connected to peer:', this.targetPeerId);\r\n      }\r\n\r\n      // Update state - Note: NgrokClientState allows connected->connected transition\r\n      // to handle multiple data channels opening on the same connection\r\n      this.state.setState(NgrokClientState.STATES.CONNECTED, {\r\n        peerId: this.targetPeerId,\r\n        timestamp: new Date(),\r\n      });\r\n\r\n      // Process any queued messages\r\n      this.processMessageQueue();\r\n\r\n      // Emit ready event\r\n      const handler = this.messageHandlers.get('ready');\r\n      if (handler) {\r\n        handler({\r\n          status: 'connected',\r\n          peerId: this.targetPeerId,\r\n          state: this.state.getState(),\r\n          timestamp: new Date().toISOString(),\r\n        });\r\n      }\r\n    });\r\n\r\n    this.connection.on('data', (data) => {\r\n      if (data.event === 'pong') {\r\n        this.lastPingTime = Date.now();\r\n        // Update latency metrics\r\n        const latency = Date.now() - data.data.timestamp;\r\n        this.state.updateMetrics({ latency });\r\n        return;\r\n      }\r\n      if (DEBUG.PEER) {\r\n        console.log('Received data from peer:', data);\r\n      }\r\n      this.handleIncomingData(data);\r\n    });\r\n\r\n    this.connection.on('close', () => {\r\n      if (DEBUG.PEER) {\r\n        console.log('Peer connection closed');\r\n      }\r\n\r\n      if (!this._isClosing) {\r\n        this.state.setState(NgrokClientState.STATES.DISCONNECTED, {\r\n          reason: 'connection_closed',\r\n        });\r\n        this._handleReconnection({ type: 'connection_closed' });\r\n      }\r\n    });\r\n\r\n    this.connection.on('error', (error) => {\r\n      console.error('Data connection error:', error);\r\n\r\n      this.state.setState(NgrokClientState.STATES.ERROR, {\r\n        error: error.message,\r\n        type: error.type,\r\n      });\r\n\r\n      this.handleError(error);\r\n      this._handleReconnection(error);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle incoming data from peer with enhanced error handling\r\n   * @private\r\n   * @param {Object} data - Data received from peer\r\n   * @param {string} data.event - Event type\r\n   * @param {*} data.data - Event data\r\n   */\r\n  handleIncomingData(data) {\r\n    try {\r\n      if (DEBUG.PEER) {\r\n        console.log(\r\n          'PeerConnection: Received event:',\r\n          data.event,\r\n          'with data:',\r\n          data.data,\r\n        );\r\n      }\r\n\r\n      // First, try to find a specific handler for this event\r\n      const handler = this.messageHandlers.get(data.event);\r\n\r\n      if (handler) {\r\n        if (DEBUG.PEER) {\r\n          console.log(\r\n            'PeerConnection: Found specific handler for event:',\r\n            data.event,\r\n          );\r\n        }\r\n        handler({\r\n          ...data.data,\r\n          timestamp: Date.now(),\r\n          state: this.state.getState(),\r\n        });\r\n      } else {\r\n        if (DEBUG.PEER) {\r\n          console.log(\r\n            'PeerConnection: No specific handler for event:',\r\n            data.event,\r\n            'forwarding to data handler',\r\n          );\r\n        }\r\n        // If no specific handler is found, forward the event to the data handler\r\n        // This ensures all events are forwarded to the Kinectron class\r\n        const dataHandler = this.messageHandlers.get('data');\r\n\r\n        // if (data.event === 'bodyFrame') debugger;\r\n\r\n        if (dataHandler) {\r\n          dataHandler(data);\r\n        } else {\r\n          console.warn(\r\n            'PeerConnection: No data handler found for event:',\r\n            data.event,\r\n          );\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error handling incoming data:', error);\r\n      this.handleError({\r\n        type: 'data_handling_error',\r\n        message: 'Error processing received data',\r\n        originalError: error,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process queued messages\r\n   * @private\r\n   */\r\n  async processMessageQueue() {\r\n    while (\r\n      this.messageQueue.length > 0 &&\r\n      this.state.getState() === NgrokClientState.STATES.CONNECTED\r\n    ) {\r\n      const message = this.messageQueue.shift();\r\n      try {\r\n        await this.send(message.event, message.data);\r\n      } catch (error) {\r\n        console.error('Failed to send queued message:', error);\r\n        // Re-queue message if connection is still open\r\n        if (\r\n          this.state.getState() ===\r\n            NgrokClientState.STATES.CONNECTED &&\r\n          this.messageQueue.length < this.maxQueueSize\r\n        ) {\r\n          this.messageQueue.push(message);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Register a handler for a specific event type with validation\r\n   * @param {string} event - Event type to handle\r\n   * @param {Function} handler - Handler function for the event\r\n   */\r\n  on(event, handler) {\r\n    if (typeof handler !== 'function') {\r\n      throw new Error('Handler must be a function');\r\n    }\r\n    this.messageHandlers.set(event, handler);\r\n  }\r\n\r\n  /**\r\n   * Send data to peer with enhanced reliability\r\n   * @param {string} event - Event type\r\n   * @param {*} data - Data to send\r\n   * @returns {Promise<void>}\r\n   */\r\n  async send(event, data) {\r\n    return new Promise((resolve, reject) => {\r\n      if (\r\n        this.state.getState() !== NgrokClientState.STATES.CONNECTED ||\r\n        !this.connection?.open\r\n      ) {\r\n        // Queue message if not connected\r\n        if (this.messageQueue.length < this.maxQueueSize) {\r\n          this.messageQueue.push({ event, data });\r\n          resolve(); // Resolve since message was queued\r\n        } else {\r\n          reject(new Error('Message queue full'));\r\n        }\r\n        return;\r\n      }\r\n\r\n      try {\r\n        const message = {\r\n          event,\r\n          data,\r\n          timestamp: Date.now(),\r\n        };\r\n\r\n        const timeout = setTimeout(() => {\r\n          reject(new Error('Send timeout'));\r\n        }, 5000);\r\n\r\n        this.connection.send(message);\r\n        clearTimeout(timeout);\r\n        resolve();\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Close the peer connection with graceful shutdown\r\n   */\r\n  async close() {\r\n    this._isClosing = true;\r\n\r\n    // Send shutdown message if possible\r\n    if (this.connection?.open) {\r\n      try {\r\n        await this.send('shutdown', { reason: 'client_close' });\r\n      } catch (error) {\r\n        console.error('Error sending shutdown message:', error);\r\n      }\r\n    }\r\n\r\n    // Clean up resources\r\n    await this._cleanup(true);\r\n\r\n    // Reset state\r\n    this.state.reset();\r\n    this.messageQueue = [];\r\n    this._isClosing = false;\r\n  }\r\n\r\n  /**\r\n   * Check if peer is connected\r\n   * @returns {boolean} Connection status\r\n   */\r\n  isConnected() {\r\n    return (\r\n      this.state.getState() === NgrokClientState.STATES.CONNECTED &&\r\n      this.connection?.open\r\n    );\r\n  }\r\n}\r\n","/**\r\n * Utility functions for processing image data from different streams\r\n */\r\n\r\nimport { DEBUG, log } from './debug.js';\r\n\r\n/**\r\n * Process image data from a frame\r\n * @param {Object} frameData - The frame data containing image information\r\n * @param {number} width - The width of the image\r\n * @param {number} height - The height of the image\r\n * @param {Function} callback - Callback to receive the processed image\r\n */\r\nexport function processImageData(frameData, callback) {\r\n  // Check for both imagedata and imageData formats\r\n  const imagedata = frameData.imagedata || frameData.imageData;\r\n\r\n  if (!frameData || !imagedata) {\r\n    log.warn('Invalid frame data received:', frameData);\r\n    return;\r\n  }\r\n\r\n  const { width, height } = imagedata;\r\n\r\n  // Create a canvas to convert image data to a data URL\r\n  const canvas = document.createElement('canvas');\r\n  const ctx = canvas.getContext('2d');\r\n\r\n  canvas.width = width;\r\n  canvas.height = height;\r\n\r\n  try {\r\n    // Check if data is a string (data URL)\r\n    if (typeof imagedata.data === 'string') {\r\n      log.data('Processing image data from data URL');\r\n      createImageFromDataUrl(\r\n        imagedata.data,\r\n        width,\r\n        height,\r\n        (src) => {\r\n          // Call the user callback with processed frame\r\n          callback({\r\n            src,\r\n            width,\r\n            height,\r\n            raw: imagedata,\r\n            timestamp: frameData.timestamp || Date.now(),\r\n          });\r\n        },\r\n        (err) => {\r\n          log.error('Error loading image from data URL:', err);\r\n          // Try to call callback anyway with the raw data\r\n          callback({\r\n            src: imagedata.data,\r\n            width,\r\n            height,\r\n            raw: imagedata,\r\n            timestamp: frameData.timestamp || Date.now(),\r\n          });\r\n        },\r\n      );\r\n    } else {\r\n      log.data('Processing image data from raw pixel data');\r\n      // Handle raw pixel data\r\n      const pixelData = convertToUint8ClampedArray(imagedata.data);\r\n      const imgData = new ImageData(pixelData, width, height);\r\n\r\n      // Put the image data on the canvas\r\n      ctx.putImageData(imgData, 0, 0);\r\n\r\n      // Convert to data URL for easy display\r\n      const src = canvas.toDataURL('image/jpeg');\r\n\r\n      // Call the user callback with processed frame\r\n      callback({\r\n        src,\r\n        width,\r\n        height,\r\n        raw: imagedata,\r\n        timestamp: frameData.timestamp || Date.now(),\r\n      });\r\n    }\r\n  } catch (error) {\r\n    log.error('Error processing frame:', error);\r\n    log.error('Frame data:', imagedata);\r\n  }\r\n}\r\n\r\n/**\r\n * Create an image from a data URL\r\n * @param {string} dataUrl - The data URL\r\n * @param {number} width - The width of the image\r\n * @param {number} height - The height of the image\r\n * @param {Function} onSuccess - Success callback with the data URL\r\n * @param {Function} onError - Error callback\r\n */\r\nexport function createImageFromDataUrl(\r\n  dataUrl,\r\n  width,\r\n  height,\r\n  onSuccess,\r\n  onError,\r\n) {\r\n  const canvas = document.createElement('canvas');\r\n  const ctx = canvas.getContext('2d');\r\n\r\n  canvas.width = width;\r\n  canvas.height = height;\r\n\r\n  // Create an image from the data URL\r\n  const img = new Image();\r\n\r\n  img.onload = () => {\r\n    // Draw the image to the canvas\r\n    ctx.drawImage(img, 0, 0, width, height);\r\n\r\n    // Use the original data URL\r\n    onSuccess(dataUrl);\r\n  };\r\n\r\n  // Set error handler\r\n  img.onerror = (err) => {\r\n    if (onError) {\r\n      onError(err);\r\n    }\r\n  };\r\n\r\n  // Start loading the image\r\n  img.src = dataUrl;\r\n}\r\n\r\n/**\r\n * Convert various data formats to Uint8ClampedArray\r\n * @param {*} data - The data to convert\r\n * @returns {Uint8ClampedArray} - The converted data\r\n */\r\nexport function convertToUint8ClampedArray(data) {\r\n  if (data instanceof Uint8ClampedArray) {\r\n    return data;\r\n  } else if (data instanceof Uint8Array) {\r\n    return new Uint8ClampedArray(data);\r\n  } else if (Array.isArray(data)) {\r\n    return new Uint8ClampedArray(data);\r\n  } else {\r\n    // Handle case where data is an object (e.g., from JSON)\r\n    return new Uint8ClampedArray(Object.values(data));\r\n  }\r\n}\r\n","/**\r\n * Stream handler factory functions\r\n */\r\n\r\nimport * as imageUtils from '../utils/imageProcessing.js';\r\nimport { DEBUG, log } from '../utils/debug.js';\r\n\r\n/**\r\n * Create a frame handler for image-based streams\r\n * @param {string} streamType - The type of stream ('color', 'depth', 'key', etc.)\r\n * @param {Function} callback - The callback to receive processed frames\r\n * @returns {Function} - The frame handler function\r\n */\r\nexport function createFrameHandler(streamType, callback) {\r\n  return (data) => {\r\n    // Extract the actual frame data\r\n    const frameData = data.data || data;\r\n\r\n    log.handler(\r\n      `Frame handler for ${streamType} received:`,\r\n      frameData,\r\n    );\r\n\r\n    // Check for both imagedata and imageData formats\r\n    const hasImageData = frameData.imagedata || frameData.imageData;\r\n\r\n    // Only process frames with matching name\r\n    if (frameData.name === streamType && hasImageData) {\r\n      // Normalize the data structure to ensure imagedata exists\r\n      if (frameData.imageData && !frameData.imagedata) {\r\n        frameData.imagedata = frameData.imageData;\r\n      }\r\n\r\n      // Process the image data\r\n      imageUtils.processImageData(frameData, callback);\r\n    } else {\r\n      log.warn(\r\n        `Received frame event but it's not a valid ${streamType} frame:`,\r\n        'name=',\r\n        frameData.name,\r\n        'has imagedata=',\r\n        !!(frameData.imagedata || frameData.imageData),\r\n      );\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Create a handler for raw depth data\r\n * @param {Function} callback - The callback to receive processed frames\r\n * @param {Function} unpackFunction - Function to unpack raw depth data\r\n * @returns {Function} - The raw depth handler function\r\n */\r\nexport function createRawDepthHandler(callback, unpackFunction) {\r\n  return (data) => {\r\n    if (data && data.imagedata) {\r\n      // Process the data regardless of isPacked flag\r\n      // The new implementation always unpacks the data\r\n      unpackFunction(\r\n        data.imagedata,\r\n        data.width,\r\n        data.height,\r\n        data.width, // originalWidth is the same as width in new implementation\r\n        data.testValues, // Pass test values to unpacking function\r\n      )\r\n        .then((depthValues) => {\r\n          // Call the callback with the unpacked data\r\n          callback({\r\n            ...data,\r\n            depthValues: depthValues,\r\n            timestamp: data.timestamp || Date.now(),\r\n          });\r\n        })\r\n        .catch((error) => {\r\n          log.error('Error unpacking raw depth data:', error);\r\n          // Still call the callback with the original data\r\n          callback({\r\n            ...data,\r\n            error: 'Failed to unpack depth data: ' + error.message,\r\n            timestamp: data.timestamp || Date.now(),\r\n          });\r\n        });\r\n    } else if (data && data.rawDepthData) {\r\n      // Legacy format - raw depth data is already in a usable format\r\n      callback({\r\n        ...data,\r\n        timestamp: data.timestamp || Date.now(),\r\n      });\r\n    } else {\r\n      log.warn(\r\n        'Received raw depth frame with invalid data format:',\r\n        data,\r\n      );\r\n      callback({\r\n        ...data,\r\n        error: 'Invalid data format',\r\n        timestamp: data.timestamp || Date.now(),\r\n      });\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Create a handler for body tracking data\r\n * @param {Function} callback - The callback to receive processed frames\r\n * @returns {Function} - The body handler function\r\n */\r\nexport function createBodyHandler(callback) {\r\n  log.handler('Creating body handler with callback:', callback);\r\n\r\n  return (eventData) => {\r\n    const bodyData = eventData.data;\r\n    if (bodyData && bodyData.bodies) {\r\n      // Body data is already in a usable format (array of body objects)\r\n      // Just add timestamp and pass it through\r\n      callback({\r\n        bodies: bodyData.bodies,\r\n        timestamp: bodyData.timestamp || Date.now(),\r\n        floorClipPlane: bodyData.floorClipPlane,\r\n        trackingId: bodyData.trackingId,\r\n      });\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Create a handler for multi-frame data\r\n * @param {Function} callback - The callback to receive processed frames\r\n * @returns {Function} - The multi-frame handler function\r\n */\r\nexport function createMultiFrameHandler(callback) {\r\n  return (data) => {\r\n    if (data && data.frames) {\r\n      // Process each frame based on its type\r\n      const processedFrames = {};\r\n\r\n      // Process each frame in the multiframe data\r\n      Object.entries(data.frames).forEach(([type, frameData]) => {\r\n        if (frameData.imagedata) {\r\n          // For image-based frames, convert to data URL\r\n          const canvas = document.createElement('canvas');\r\n          const ctx = canvas.getContext('2d');\r\n          const { width, height } = frameData.imagedata;\r\n\r\n          canvas.width = width;\r\n          canvas.height = height;\r\n\r\n          // Create ImageData object from the raw data\r\n          const imgData = new ImageData(\r\n            imageUtils.convertToUint8ClampedArray(\r\n              frameData.imagedata.data,\r\n            ),\r\n            width,\r\n            height,\r\n          );\r\n\r\n          // Put the image data on the canvas\r\n          ctx.putImageData(imgData, 0, 0);\r\n\r\n          // Convert to data URL\r\n          processedFrames[type] = {\r\n            src: canvas.toDataURL('image/jpeg'),\r\n            width,\r\n            height,\r\n            raw: frameData.imagedata,\r\n          };\r\n        } else {\r\n          // For non-image data (like body tracking), pass through\r\n          processedFrames[type] = frameData;\r\n        }\r\n      });\r\n\r\n      // Call the user callback with processed frames\r\n      callback({\r\n        frames: processedFrames,\r\n        timestamp: data.timestamp || Date.now(),\r\n      });\r\n    }\r\n  };\r\n}\r\n","/**\r\n * @fileoverview Main entry point for the Kinectron client library\r\n * @version 1.0.0\r\n * @description Kinectron enables real-time streaming of Microsoft Azure Kinect data into web browsers using WebRTC.\r\n * This client library connects to a Kinectron server running on a computer with an Azure Kinect device.\r\n */\r\n\r\nimport { Kinectron } from './kinectron.js';\r\n\r\nconsole.log('You are running Kinectron API version 1.0.0');\r\n\r\n/**\r\n * Kinectron client class for connecting to a Kinectron server and accessing Azure Kinect data streams\r\n *\r\n * @module kinectron\r\n * @exports Kinectron\r\n * @example\r\n * // Using ES modules (recommended)\r\n * import Kinectron from 'kinectron';\r\n *\r\n * // Create a new Kinectron instance\r\n * const kinectron = new Kinectron('127.0.0.1');\r\n *\r\n * // Connect and initialize\r\n * kinectron.on('ready', () => {\r\n *   console.log('Connected to Kinectron server');\r\n *   kinectron.initKinect()\r\n *     .then(() => {\r\n *       // Start a color stream\r\n *       kinectron.startColor((colorFrame) => {\r\n *         // Display the color image\r\n *         document.getElementById('colorImage').src = colorFrame.src;\r\n *       });\r\n *     });\r\n * });\r\n *\r\n * // Using script tag (UMD build)\r\n * // <script src=\"https://cdn.jsdelivr.net/npm/kinectron@1.0.0/dist/kinectron.umd.js\"></script>\r\n * // const kinectron = new Kinectron('127.0.0.1');\r\n */\r\nexport default Kinectron;\r\n","import { PeerConnection } from './peer/peerConnection.js';\r\nimport { NgrokClientState } from './peer/ngrokState.js';\r\nimport { DEBUG, log } from './utils/debug.js';\r\nimport {\r\n  createFrameHandler,\r\n  createRawDepthHandler,\r\n  createBodyHandler,\r\n  createMultiFrameHandler,\r\n} from './streams/streamHandlers.js';\r\n\r\n/**\r\n * Kinectron client for connecting to a Kinectron server and accessing Azure Kinect data streams\r\n *\r\n * @class\r\n */\r\nexport class Kinectron {\r\n  /**\r\n   * Creates a new Kinectron client instance for connecting to a Kinectron server\r\n   *\r\n   * @param {Object|string} [networkConfig] - Network configuration or server IP address\r\n   * @param {string} [networkConfig.host='127.0.0.1'] - Host address for the peer server\r\n   * @param {number|string} [networkConfig.port=9001] - Port number for the peer server\r\n   * @param {string} [networkConfig.path='/'] - Path for the peer server\r\n   * @param {boolean} [networkConfig.secure=false] - Whether to use secure connection\r\n   * @param {string} [networkConfig.role='default'] - Role identifier for the connection\r\n   * @example\r\n   * // Connect to local server\r\n   * const kinectron = new Kinectron();\r\n   *\r\n   * // Connect to specific IP\r\n   * const kinectron = new Kinectron('192.168.0.1');\r\n   *\r\n   * // Connect to ngrok tunnel\r\n   * const kinectron = new Kinectron('https://abcd1234.ngrok-free.app');\r\n   *\r\n   * // Connect with custom config\r\n   * const kinectron = new Kinectron({\r\n   *   host: '192.168.0.1',\r\n   *   port: 9001,\r\n   *   secure: false\r\n   * });\r\n   */\r\n  constructor(networkConfig) {\r\n    this.peer = new PeerConnection(networkConfig);\r\n    this.messageHandlers = new Map();\r\n    this.state = null;\r\n\r\n    // Set up event handlers\r\n    this.peer.on('ready', (data) => {\r\n      this.state = data.state;\r\n      const handler = this.messageHandlers.get('ready');\r\n      if (handler) handler(data);\r\n    });\r\n\r\n    this.peer.on('error', (error) => {\r\n      const handler = this.messageHandlers.get('error');\r\n      if (handler) handler(error);\r\n    });\r\n\r\n    // Handle state changes\r\n    this.peer.on('stateChange', (data) => {\r\n      this.state = data.to;\r\n      const handler = this.messageHandlers.get('stateChange');\r\n      if (handler) handler(data);\r\n    });\r\n\r\n    // Handle metrics updates\r\n    this.peer.on('metrics', (data) => {\r\n      const handler = this.messageHandlers.get('metrics');\r\n      if (handler) handler(data);\r\n    });\r\n\r\n    // Handle incoming data\r\n    this.peer.on('data', (data) => {\r\n      const { event, data: eventData } = data;\r\n      const handler = this.messageHandlers.get(event);\r\n\r\n      if (handler) {\r\n        // if (event === 'bodyFrame') debugger;\r\n\r\n        handler(eventData);\r\n      } else {\r\n        log.warn('Kinectron: No handler found for event:', event);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Register an event handler for a specific event type\r\n   *\r\n   * @param {string} event - Event type to handle\r\n   * @param {Function} callback - Handler function for the event\r\n   * @example\r\n   * // Handle connection ready event\r\n   * kinectron.on('ready', (data) => {\r\n   *   console.log('Connected to Kinectron server!');\r\n   * });\r\n   *\r\n   * // Handle connection errors\r\n   * kinectron.on('error', (error) => {\r\n   *   console.error('Connection error:', error);\r\n   * });\r\n   *\r\n   * // Handle state changes\r\n   * kinectron.on('stateChange', (data) => {\r\n   *   console.log('Connection state changed from', data.from, 'to', data.to);\r\n   * });\r\n   */\r\n  on(event, callback) {\r\n    this.messageHandlers.set(event, callback);\r\n  }\r\n\r\n  /**\r\n   * Get the current connection state and metadata\r\n   *\r\n   * @returns {Object} Current state information including connection status, metrics, and error history\r\n   * @example\r\n   * const state = kinectron.getState();\r\n   * console.log('Connection state:', state.currentState);\r\n   * console.log('Connection quality:', state.metrics.connectionQuality);\r\n   * console.log('Latency:', state.metrics.latency.current, 'ms');\r\n   */\r\n  getState() {\r\n    return this.peer.getState();\r\n  }\r\n\r\n  /**\r\n   * Check if the client is currently connected to a Kinectron server\r\n   *\r\n   * @returns {boolean} True if connected, false otherwise\r\n   * @example\r\n   * if (kinectron.isConnected()) {\r\n   *   console.log('Connected to Kinectron server');\r\n   * } else {\r\n   *   console.log('Not connected');\r\n   * }\r\n   */\r\n  isConnected() {\r\n    return this.state === NgrokClientState.STATES.CONNECTED;\r\n  }\r\n\r\n  /**\r\n   * Set the Kinect hardware type to use\r\n   *\r\n   * @param {string} kinectType - The type of Kinect hardware ('azure' or 'windows')\r\n   * @returns {void}\r\n   * @example\r\n   * // Set to Azure Kinect\r\n   * kinectron.setKinectType('azure');\r\n   *\r\n   * // Set to Kinect for Windows v2\r\n   * kinectron.setKinectType('windows');\r\n   */\r\n  setKinectType(kinectType) {\r\n    if (!this.isConnected()) {\r\n      log.warn('Cannot set Kinect type: not connected');\r\n      return;\r\n    }\r\n    this.send('setkinect', kinectType);\r\n  }\r\n\r\n  /**\r\n   * Initialize the Kinect hardware on the server\r\n   *\r\n   * @param {Function} [callback] - Optional callback for backward compatibility\r\n   * @returns {Promise<Object>} Promise resolving to initialization result\r\n   * @throws {Error} If not connected or initialization fails\r\n   * @example\r\n   * // Using Promise-based approach (recommended)\r\n   * kinectron.initKinect()\r\n   *   .then(result => {\r\n   *     console.log('Kinect initialized:', result.success);\r\n   *     // Start streams after successful initialization\r\n   *     kinectron.startColor(handleColorFrame);\r\n   *   })\r\n   *   .catch(error => {\r\n   *     console.error('Failed to initialize Kinect:', error);\r\n   *   });\r\n   *\r\n   * // Using callback approach (legacy)\r\n   * kinectron.initKinect((result) => {\r\n   *   if (result.success) {\r\n   *     console.log('Kinect initialized successfully');\r\n   *     // Start streams after successful initialization\r\n   *     kinectron.startColor(handleColorFrame);\r\n   *   } else {\r\n   *     console.error('Failed to initialize Kinect:', result.error);\r\n   *   }\r\n   * });\r\n   */\r\n  initKinect(callback) {\r\n    if (!this.isConnected()) {\r\n      log.warn('Cannot initialize Kinect: not connected');\r\n      return Promise.reject(\r\n        new Error('Cannot initialize Kinect: not connected'),\r\n      );\r\n    }\r\n\r\n    // Create a promise that resolves when we get the kinectInitialized event\r\n    const initPromise = new Promise((resolve, reject) => {\r\n      // Set up a one-time handler for the initialization response\r\n      const handler = (data) => {\r\n        // Normalize the success value to handle nested structure\r\n        let isSuccess = false;\r\n        if (\r\n          data.success &&\r\n          typeof data.success === 'object' &&\r\n          data.success.success === true\r\n        ) {\r\n          isSuccess = true;\r\n        } else if (\r\n          typeof data.success === 'boolean' &&\r\n          data.success === true\r\n        ) {\r\n          isSuccess = true;\r\n        }\r\n\r\n        // Create a normalized result object\r\n        const normalizedResult = {\r\n          success: isSuccess,\r\n          alreadyInitialized: !!data.alreadyInitialized,\r\n          error: data.error || null,\r\n          rawData: data, // Include the original data for debugging\r\n        };\r\n\r\n        if (isSuccess || data.alreadyInitialized) {\r\n          resolve(normalizedResult);\r\n        } else {\r\n          reject(\r\n            new Error(data.error || 'Failed to initialize Kinect'),\r\n          );\r\n        }\r\n\r\n        // Remove the handler after it's been called\r\n        this.messageHandlers.delete('kinectInitialized');\r\n      };\r\n\r\n      this.messageHandlers.set('kinectInitialized', handler);\r\n\r\n      // Send initialization request to server\r\n      this.send('initkinect', {});\r\n    });\r\n\r\n    // For backward compatibility, if a callback is provided, use it\r\n    if (callback) {\r\n      initPromise\r\n        .then((data) => callback(data))\r\n        .catch((error) =>\r\n          callback({ success: false, error: error.message }),\r\n        );\r\n    }\r\n\r\n    // Return the promise for modern Promise-based usage\r\n    return initPromise;\r\n  }\r\n\r\n  /**\r\n   * Send data to the Kinectron server\r\n   *\r\n   * @param {string} event - Event type\r\n   * @param {*} data - Data to send\r\n   * @returns {void}\r\n   * @example\r\n   * // Send custom data to the server\r\n   * kinectron.send('custom-event', { message: 'Hello from client' });\r\n   */\r\n  send(event, data) {\r\n    if (!this.isConnected()) {\r\n      log.warn('Cannot send data: not connected');\r\n      return;\r\n    }\r\n    this.peer.send(event, data);\r\n  }\r\n\r\n  /**\r\n   * Start the color camera stream\r\n   *\r\n   * @param {Function} [callback] - Callback function that receives color frames\r\n   * @returns {void}\r\n   * @example\r\n   * kinectron.startColor((colorFrame) => {\r\n   *   // colorFrame contains:\r\n   *   // - src: Data URL of the color image\r\n   *   // - width: Image width\r\n   *   // - height: Image height\r\n   *   // - raw: Raw image data\r\n   *   // - timestamp: Frame timestamp\r\n   *\r\n   *   // Display the color image\r\n   *   const img = document.getElementById('colorImage');\r\n   *   img.src = colorFrame.src;\r\n   * });\r\n   */\r\n  startColor(callback) {\r\n    if (callback) {\r\n      // Set up frame handler to process color frames\r\n      this.messageHandlers.set(\r\n        'frame',\r\n        createFrameHandler('color', callback),\r\n      );\r\n    }\r\n    this.send('feed', { feed: 'color' });\r\n  }\r\n\r\n  /**\r\n   * Start the depth camera stream (processed depth image)\r\n   *\r\n   * @param {Function} [callback] - Callback function that receives depth frames\r\n   * @returns {void}\r\n   * @example\r\n   * kinectron.startDepth((depthFrame) => {\r\n   *   // depthFrame contains:\r\n   *   // - src: Data URL of the depth image (colorized)\r\n   *   // - width: Image width\r\n   *   // - height: Image height\r\n   *   // - raw: Raw image data\r\n   *   // - timestamp: Frame timestamp\r\n   *\r\n   *   // Display the depth image\r\n   *   const img = document.getElementById('depthImage');\r\n   *   img.src = depthFrame.src;\r\n   * });\r\n   */\r\n  startDepth(callback) {\r\n    if (callback) {\r\n      // Set up frame handler to process depth frames\r\n      this.messageHandlers.set(\r\n        'frame',\r\n        createFrameHandler('depth', callback),\r\n      );\r\n    }\r\n    this.send('feed', { feed: 'depth' });\r\n  }\r\n\r\n  /**\r\n   * Unpacks raw depth data from a WebP image\r\n   * @private\r\n   * @param {string} dataUrl - The data URL containing the depth data\r\n   * @param {number} width - The width of the image\r\n   * @param {number} height - The height of the image\r\n   * @param {number} originalWidth - The original width of the depth data (not used in new implementation)\r\n   * @param {Object} testValues - Test values to verify unpacking accuracy\r\n   * @returns {Promise<Uint16Array>} - Promise resolving to the unpacked depth values\r\n   */\r\n  _unpackRawDepthData(\r\n    dataUrl,\r\n    width,\r\n    height,\r\n    originalWidth,\r\n    testValues,\r\n  ) {\r\n    // Log using the imported debug module\r\n    if (DEBUG.DATA) {\r\n      log.data(\r\n        'Unpacking raw depth data with dimensions:',\r\n        width,\r\n        'x',\r\n        height,\r\n      );\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Create image to load the data URL\r\n      const img = new Image();\r\n      img.onload = () => {\r\n        // Use OffscreenCanvas for efficient processing\r\n        const canvas = new OffscreenCanvas(width, height);\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        // Draw the image to the canvas\r\n        ctx.drawImage(img, 0, 0);\r\n\r\n        // Get the pixel data\r\n        const imageData = ctx.getImageData(0, 0, width, height).data;\r\n\r\n        // Create array for unpacked depth values\r\n        const depthValues = new Uint16Array(width * height);\r\n\r\n        // Process the raw depth data exactly like the app.js client code\r\n        let j = 0;\r\n        for (let i = 0; i < imageData.length; i += 4) {\r\n          // Extract depth value from R and G channels\r\n          const depth = (imageData[i + 1] << 8) | imageData[i]; // Get uint16 data from buffer\r\n          depthValues[j++] = depth;\r\n        }\r\n\r\n        // Verify test values if provided\r\n        if (testValues && DEBUG.DATA) {\r\n          const unpackedValue1000 = depthValues[1000];\r\n          const unpackedValue2000 = depthValues[2000];\r\n          const unpackedValue3000 = depthValues[3000];\r\n\r\n          log.data('Test values comparison:', {\r\n            'Index 1000': {\r\n              Original: testValues.index1000,\r\n              Unpacked: unpackedValue1000,\r\n              Difference: testValues.index1000 - unpackedValue1000,\r\n            },\r\n            'Index 2000': {\r\n              Original: testValues.index2000,\r\n              Unpacked: unpackedValue2000,\r\n              Difference: testValues.index2000 - unpackedValue2000,\r\n            },\r\n            'Index 3000': {\r\n              Original: testValues.index3000,\r\n              Unpacked: unpackedValue3000,\r\n              Difference: testValues.index3000 - unpackedValue3000,\r\n            },\r\n          });\r\n        }\r\n\r\n        resolve(depthValues);\r\n      };\r\n\r\n      img.onerror = (err) => {\r\n        reject(new Error('Failed to load depth image: ' + err));\r\n      };\r\n\r\n      img.src = dataUrl;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Start the raw depth stream (16-bit depth values)\r\n   *\r\n   * @param {Function} [callback] - Callback function that receives raw depth frames\r\n   * @returns {void}\r\n   * @example\r\n   * kinectron.startRawDepth((rawDepthFrame) => {\r\n   *   // rawDepthFrame contains:\r\n   *   // - depthValues: Uint16Array of 16-bit depth values\r\n   *   // - width: Frame width\r\n   *   // - height: Frame height\r\n   *   // - timestamp: Frame timestamp\r\n   *\r\n   *   // Access raw depth values\r\n   *   const depthValues = rawDepthFrame.depthValues;\r\n   *\r\n   *   // Example: Find minimum and maximum depth\r\n   *   let min = Infinity;\r\n   *   let max = 0;\r\n   *   for (let i = 0; i < depthValues.length; i++) {\r\n   *     if (depthValues[i] > 0) { // Ignore zero values (no data)\r\n   *       min = Math.min(min, depthValues[i]);\r\n   *       max = Math.max(max, depthValues[i]);\r\n   *     }\r\n   *   }\r\n   *   console.log(`Depth range: ${min}mm to ${max}mm`);\r\n   * });\r\n   */\r\n  startRawDepth(callback) {\r\n    if (callback) {\r\n      // Set up handler to process raw depth frames\r\n      this.messageHandlers.set(\r\n        'rawDepth',\r\n        createRawDepthHandler(\r\n          callback,\r\n          this._unpackRawDepthData.bind(this),\r\n        ),\r\n      );\r\n    }\r\n    this.send('feed', { feed: 'raw-depth' });\r\n  }\r\n\r\n  /**\r\n   * Start the body tracking stream\r\n   *\r\n   * @param {Function} [callback] - Callback function that receives body tracking frames\r\n   * @returns {void}\r\n   * @example\r\n   * kinectron.startBodies((bodyFrame) => {\r\n   *   // bodyFrame contains:\r\n   *   // - bodies: Array of tracked bodies\r\n   *   // - timestamp: Frame timestamp\r\n   *   // - floorClipPlane: Floor plane data\r\n   *   // - trackingId: Tracking session ID\r\n   *\r\n   *   // Process each tracked body\r\n   *   bodyFrame.bodies.forEach(body => {\r\n   *     // Each body contains joint positions and orientations\r\n   *     const joints = body.joints;\r\n   *\r\n   *     // Example: Get head position\r\n   *     const head = joints.find(joint => joint.name === 'head');\r\n   *     if (head) {\r\n   *       console.log('Head position:', head.position);\r\n   *     }\r\n   *   });\r\n   * });\r\n   */\r\n  startBodies(callback) {\r\n    if (callback) {\r\n      // Set up handler to process body tracking frames\r\n      this.messageHandlers.set(\r\n        'bodyFrame',\r\n        createBodyHandler(callback),\r\n      );\r\n    }\r\n    this.send('feed', { feed: 'body' });\r\n  }\r\n\r\n  /**\r\n   * Start the key (green screen) stream\r\n   *\r\n   * @param {Function} [callback] - Callback function that receives key frames\r\n   * @returns {void}\r\n   * @example\r\n   * kinectron.startKey((keyFrame) => {\r\n   *   // keyFrame contains:\r\n   *   // - src: Data URL of the key image (color with background removed)\r\n   *   // - width: Image width\r\n   *   // - height: Image height\r\n   *   // - raw: Raw image data\r\n   *   // - timestamp: Frame timestamp\r\n   *\r\n   *   // Display the key image\r\n   *   const img = document.getElementById('keyImage');\r\n   *   img.src = keyFrame.src;\r\n   * });\r\n   */\r\n  startKey(callback) {\r\n    if (callback) {\r\n      // Set up frame handler to process key frames\r\n      this.messageHandlers.set(\r\n        'frame',\r\n        createFrameHandler('key', callback),\r\n      );\r\n    }\r\n    this.send('feed', { feed: 'key' });\r\n  }\r\n\r\n  /**\r\n   * Start the depth key stream (depth data with background removed)\r\n   *\r\n   * @param {Function} [callback] - Callback function that receives depth key frames\r\n   * @returns {void}\r\n   * @example\r\n   * kinectron.startDepthKey((depthKeyFrame) => {\r\n   *   // depthKeyFrame contains:\r\n   *   // - src: Data URL of the depth key image\r\n   *   // - width: Image width\r\n   *   // - height: Image height\r\n   *   // - raw: Raw image data\r\n   *   // - timestamp: Frame timestamp\r\n   *\r\n   *   // Display the depth key image\r\n   *   const img = document.getElementById('depthKeyImage');\r\n   *   img.src = depthKeyFrame.src;\r\n   * });\r\n   */\r\n  startDepthKey(callback) {\r\n    if (callback) {\r\n      // Set up handler to process depth key frames\r\n      this.messageHandlers.set(\r\n        'depth-key', // Changed from 'depthKey' to match server's broadcast event name\r\n        createFrameHandler('depth-key', callback),\r\n      );\r\n    }\r\n    this.send('feed', { feed: 'depth-key' });\r\n  }\r\n\r\n  /**\r\n   * Start the RGBD stream (aligned color and depth)\r\n   *\r\n   * @param {Function} [callback] - Callback function that receives RGBD frames\r\n   * @returns {void}\r\n   * @example\r\n   * kinectron.startRGBD((rgbdFrame) => {\r\n   *   // rgbdFrame contains:\r\n   *   // - src: Data URL of the RGBD image\r\n   *   // - width: Image width\r\n   *   // - height: Image height\r\n   *   // - raw: Raw image data\r\n   *   // - timestamp: Frame timestamp\r\n   *\r\n   *   // Display the RGBD image\r\n   *   const img = document.getElementById('rgbdImage');\r\n   *   img.src = rgbdFrame.src;\r\n   * });\r\n   */\r\n  startRGBD(callback) {\r\n    if (callback) {\r\n      // Set up frame handler to process RGBD frames\r\n      this.messageHandlers.set(\r\n        'frame',\r\n        createFrameHandler('rgbd', callback),\r\n      );\r\n    }\r\n    this.send('feed', { feed: 'rgbd' });\r\n  }\r\n\r\n  /**\r\n   * Start multiple streams simultaneously\r\n   *\r\n   * @param {string[]} frames - Array of stream types to start ('color', 'depth', 'body', etc.)\r\n   * @param {Function} [callback] - Callback function that receives multi-frame data\r\n   * @returns {void}\r\n   * @example\r\n   * // Start color and depth streams together\r\n   * kinectron.startMultiFrame(['color', 'depth'], (multiFrame) => {\r\n   *   // multiFrame contains:\r\n   *   // - frames: Object with a property for each requested stream type\r\n   *   // - timestamp: Frame timestamp\r\n   *\r\n   *   // Access individual frames\r\n   *   const colorFrame = multiFrame.frames.color;\r\n   *   const depthFrame = multiFrame.frames.depth;\r\n   *\r\n   *   // Display the images\r\n   *   document.getElementById('colorImage').src = colorFrame.src;\r\n   *   document.getElementById('depthImage').src = depthFrame.src;\r\n   * });\r\n   */\r\n  startMultiFrame(frames, callback) {\r\n    if (callback) {\r\n      // Set up handler to process multi-frame data\r\n      this.messageHandlers.set(\r\n        'multiFrame',\r\n        createMultiFrameHandler(callback),\r\n      );\r\n    }\r\n    this.send('multi', frames);\r\n  }\r\n\r\n  /**\r\n   * Stop all active streams\r\n   *\r\n   * @returns {void}\r\n   * @example\r\n   * // Stop all active streams\r\n   * kinectron.stopAll();\r\n   */\r\n  stopAll() {\r\n    this.send('feed', { feed: 'stop-all' });\r\n  }\r\n\r\n  /**\r\n   * Close the connection and clean up resources\r\n   *\r\n   * @returns {void}\r\n   * @example\r\n   * // Close the connection when done\r\n   * kinectron.close();\r\n   */\r\n  close() {\r\n    this.peer.close();\r\n    this.messageHandlers.clear();\r\n    this.state = null;\r\n  }\r\n}\r\n"],"names":["NgrokError","Error","constructor","message","details","super","this","name","timestamp","Date","toISOString","troubleshooting","NgrokValidationError","type","NgrokErrorCodes","code","DEFAULT_PEER_CONFIG","host","port","path","secure","debug","role","config","iceServers","sdpSemantics","processPeerConfig","includes","url","reason","validateNgrokUrl","error","context","NgrokClientError","NgrokClientState","static","DISCONNECTED","VALIDATING","CONNECTING","CONNECTED","RECONNECTING","ERROR","STATES","currentState","metadata","startTime","lastStateChange","errorHistory","metrics","latency","current","average","samples","connectionQuality","reconnects","count","lastAttempt","errors","total","byType","handlers","stateChange","Set","on","event","handler","add","off","delete","_emit","data","forEach","getState","getMetadata","uptime","_calculateUptime","updateMetrics","undefined","push","value","length","shift","reduce","sum","sample","_updateConnectionQuality","setState","newState","_isValidTransition","from","to","oldState","recordError","errorRecord","state","unshift","pop","reset","now","getTime","avgLatency","recentErrors","filter","e","validNextStates","VALID_TRANSITIONS","log","args","console","warn","PeerConnection","networkConfig","peerId","peer","connection","targetPeerId","messageHandlers","Map","messageQueue","maxQueueSize","lastPingTime","pingInterval","healthCheckInterval","clientId","generateClientId","get","initialize","toString","random","Math","substr","isNgrok","Peer","reliable","retries","timeout","setupPeerEventHandlers","startHealthCheck","handleError","id","connect","_cleanup","shouldAttemptReconnection","_handleReconnection","clearInterval","setInterval","checkConnectionHealth","open","sendPing","handleConnectionFailure","timeSinceLastPing","send","close","status","_getErrorMessage","network","disconnected","_setConnectionTimeout","setTimeout","attempt","baseDelay","min","pow","jitter","delay","max","Promise","resolve","isClosing","destroy","connections","existingConn","setupConnectionHandlers","serialization","processMessageQueue","handleIncomingData","_isClosing","dataHandler","originalError","set","reject","clearTimeout","isConnected","processImageData","frameData","callback","imagedata","imageData","width","height","canvas","document","createElement","ctx","getContext","dataUrl","onSuccess","onError","img","Image","onload","drawImage","onerror","err","src","createImageFromDataUrl","raw","pixelData","convertToUint8ClampedArray","imgData","ImageData","putImageData","toDataURL","Uint8ClampedArray","Uint8Array","Array","isArray","Object","values","createFrameHandler","streamType","hasImageData","imageUtils.processImageData","eventData","setKinectType","kinectType","initKinect","initPromise","isSuccess","success","normalizedResult","alreadyInitialized","rawData","then","catch","startColor","feed","startDepth","_unpackRawDepthData","originalWidth","testValues","OffscreenCanvas","getImageData","depthValues","Uint16Array","j","i","depth","startRawDepth","unpackFunction","rawDepthData","createRawDepthHandler","bind","startBodies","bodyData","bodies","floorClipPlane","trackingId","createBodyHandler","startKey","startDepthKey","startRGBD","startMultiFrame","frames","processedFrames","entries","imageUtils.convertToUint8ClampedArray","createMultiFrameHandler","stopAll","clear"],"mappings":"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"}