import e from"peerjs";class t extends Error{constructor(e,t={}){super(e),this.name="NgrokError",this.details=t,this.timestamp=(new Date).toISOString(),this.troubleshooting=["Verify the ngrok tunnel is running","Check if the ngrok URL is correct","Ensure the Kinectron application is running"]}}class n extends t{constructor(e,t={}){super(e,{...t,type:"validation_error"}),this.name="NgrokValidationError",this.troubleshooting=['Ensure the URL includes "ngrok-free.app"',"Copy the URL directly from the Kinectron application","Make sure to include the full domain name"]}}const a={code:"NGROK_001",message:"Invalid ngrok URL format"};const s={host:"127.0.0.1",port:9001,path:"/",secure:!1,debug:3,role:"default",config:{iceServers:[],sdpSemantics:"unified-plan"}};function i(e){if(!e)return s;if("string"==typeof e&&e.includes("ngrok"))try{return function(e){if(!e.includes("ngrok-free.app"))throw new n(a.message,{code:a.code,url:e,reason:"URL must include ngrok-free.app domain"})}(e),{host:e,port:"443",path:"/",secure:!0,debug:3,config:{iceServers:[],sdpSemantics:"unified-plan"}}}catch(e){throw e instanceof n&&(e.details.context="peer_config_validation",e.details.timestamp=(new Date).toISOString()),e}return"string"==typeof e?{...s,host:e}:{...s,...e}}class r extends Error{constructor(e,t={}){super(e),this.name="NgrokClientError",this.details=t,this.timestamp=(new Date).toISOString(),this.troubleshooting=["Check if the ngrok tunnel is running","Verify the URL is correct","Ensure the Kinectron application is running"]}}class o{static STATES={DISCONNECTED:"disconnected",VALIDATING:"validating",CONNECTING:"connecting",CONNECTED:"connected",RECONNECTING:"reconnecting",ERROR:"error"};static VALID_TRANSITIONS={[o.STATES.DISCONNECTED]:[o.STATES.VALIDATING,o.STATES.CONNECTING],[o.STATES.VALIDATING]:[o.STATES.CONNECTING,o.STATES.ERROR],[o.STATES.CONNECTING]:[o.STATES.CONNECTED,o.STATES.RECONNECTING,o.STATES.ERROR,o.STATES.CONNECTING],[o.STATES.CONNECTED]:[o.STATES.DISCONNECTED,o.STATES.RECONNECTING,o.STATES.ERROR,o.STATES.CONNECTED],[o.STATES.RECONNECTING]:[o.STATES.CONNECTED,o.STATES.CONNECTING,o.STATES.ERROR],[o.STATES.ERROR]:[o.STATES.DISCONNECTED,o.STATES.CONNECTING]};constructor(){this.currentState=null,this.metadata={url:null,startTime:null,lastStateChange:new Date,errorHistory:[],metrics:{latency:{current:0,average:0,samples:[]},connectionQuality:"unknown",reconnects:{count:0,lastAttempt:null},errors:{total:0,byType:{}}}},this.handlers={stateChange:new Set,error:new Set,metrics:new Set}}on(e,t){this.handlers[e]&&this.handlers[e].add(t)}off(e,t){this.handlers[e]&&this.handlers[e].delete(t)}_emit(e,t){this.handlers[e]&&this.handlers[e].forEach((e=>e(t)))}getState(){return this.currentState}getMetadata(){return{...this.metadata,currentState:this.currentState,uptime:this._calculateUptime()}}updateMetrics(e){void 0!==e.latency&&(this.metadata.metrics.latency.current=e.latency,this.metadata.metrics.latency.samples.push({value:e.latency,timestamp:new Date}),this.metadata.metrics.latency.samples.length>10&&this.metadata.metrics.latency.samples.shift(),this.metadata.metrics.latency.average=this.metadata.metrics.latency.samples.reduce(((e,t)=>e+t.value),0)/this.metadata.metrics.latency.samples.length),this._updateConnectionQuality(),this._emit("metrics",this.metadata.metrics)}setState(e,t={}){if(!this._isValidTransition(e))throw new r(`Invalid state transition from ${this.currentState} to ${e}`,{from:this.currentState,to:e,details:t});const n=this.currentState;this.currentState=e,this.metadata.lastStateChange=new Date,e===o.STATES.CONNECTED?this.metadata.startTime||(this.metadata.startTime=new Date):e===o.STATES.RECONNECTING&&(this.metadata.metrics.reconnects.count++,this.metadata.metrics.reconnects.lastAttempt=new Date),this._emit("stateChange",{from:n,to:e,timestamp:this.metadata.lastStateChange,details:t})}recordError(e,t={}){const n={name:e.name,message:e.message,timestamp:new Date,context:t,state:this.currentState};this.metadata.errorHistory.unshift(n),this.metadata.errorHistory.length>10&&this.metadata.errorHistory.pop(),this.metadata.metrics.errors.total++,this.metadata.metrics.errors.byType[e.name]=(this.metadata.metrics.errors.byType[e.name]||0)+1,this._emit("error",n)}reset(){this.currentState=null,this.metadata={url:null,startTime:null,lastStateChange:new Date,errorHistory:[],metrics:{latency:{current:0,average:0,samples:[]},connectionQuality:"unknown",reconnects:{count:0,lastAttempt:null},errors:{total:0,byType:{}}}}}_calculateUptime(){return this.metadata.startTime&&this.currentState===o.STATES.CONNECTED?Date.now()-this.metadata.startTime.getTime():0}_updateConnectionQuality(){const e=this.metadata.metrics.latency.average,t=this.metadata.errorHistory.filter((e=>Date.now()-new Date(e.timestamp).getTime()<6e4)).length;this.metadata.metrics.connectionQuality=t>2?"poor":e>1e3?"unstable":e>500?"fair":"good"}_isValidTransition(e){if(null===this.currentState)return!0;const t=o.VALID_TRANSITIONS[this.currentState];return t&&t.includes(e)}}const c=function(e,...t){console.error(e,...t)},h=function(e,...t){console.warn(e,...t)},l=function(e,...t){},d=function(e,...t){};class m{constructor(e,t){this.peer=null,this.connection=null,this.targetPeerId=t||"kinectron",this.config=i(e),this.messageHandlers=new Map,this.messageQueue=[],this.maxQueueSize=100,this.lastPingTime=0,this.pingInterval=null,this.healthCheckInterval=null,this.clientId=this.generateClientId(),this.state=new o,this.state.on("stateChange",(e=>{const t=this.messageHandlers.get("stateChange");t&&t(e)})),this.state.on("error",(e=>{const t=this.messageHandlers.get("error");t&&t(e)})),this.state.on("metrics",(e=>{const t=this.messageHandlers.get("metrics");t&&t(e)})),this.initialize()}generateClientId(){const e=Date.now().toString(36),t=Math.random().toString(36).substr(2,5);return`${this.config.host?.includes("ngrok")?"ngrok":"local"}-${this.config.role||"default"}-${e}-${t}`}getState(){return this.state.getMetadata()}initialize(){try{if(this.peer)return void console.warn("Peer already initialized");const t="string"==typeof this.config.host&&this.config.host.includes("ngrok");if(t&&(this.state.setState(o.STATES.VALIDATING),!this.config.host.includes("ngrok-free.app")))throw new r("Invalid ngrok URL format",{url:this.config.host,reason:"URL must include ngrok-free.app domain"});this.peer=new e(this.clientId,{...this.config,reliable:!0,retries:2,timeout:t?5e3:3e3,debug:0}),t||this.state.setState(o.STATES.CONNECTING),this.setupPeerEventHandlers(),this.startHealthCheck()}catch(e){console.error("Peer initialization error:",e),this.handleError(e),this.state.setState(o.STATES.ERROR,{error:e.message,context:"initialization"})}}setupPeerEventHandlers(){this.peer.on("open",(e=>{this.connect()})),this.peer.on("error",(e=>{if(console.error("Peer connection error:",e),"unavailable-id"===e.type)return this.clientId=this.generateClientId(),this._cleanup(!1),void this.initialize();this.handleError(e),this.state.setState(o.STATES.ERROR,{error:e.message,type:e.type}),this.shouldAttemptReconnection(e)&&this._handleReconnection(e)})),this.peer.on("disconnected",(()=>{this.state.setState(o.STATES.DISCONNECTED,{reason:"peer_disconnected"}),this._handleReconnection({type:"disconnected"})}))}startHealthCheck(){this.healthCheckInterval&&clearInterval(this.healthCheckInterval),this.pingInterval&&clearInterval(this.pingInterval),this.healthCheckInterval=setInterval((()=>{this.state.getState()===o.STATES.CONNECTED&&this.connection&&this.checkConnectionHealth()}),1e4),this.pingInterval=setInterval((()=>{this.state.getState()===o.STATES.CONNECTED&&this.connection?.open&&this.sendPing()}),5e3)}async checkConnectionHealth(){if(!this.connection?.open)return console.warn("Connection appears dead, attempting recovery"),void await this.handleConnectionFailure();const e=Date.now()-this.lastPingTime;e>15e3&&(console.warn("No ping response, connection may be dead"),await this.handleConnectionFailure()),this.state.updateMetrics({latency:e,timestamp:new Date})}sendPing(){try{this.connection.send({event:"ping",data:{timestamp:Date.now()}})}catch(e){console.error("Failed to send ping:",e)}}async handleConnectionFailure(){if(this.connection){try{this.connection.close()}catch(e){console.error("Error closing connection:",e)}this.connection=null}this.state.setState(o.STATES.RECONNECTING,{reason:"connection_failure",timestamp:new Date}),await this._handleReconnection({type:"connection_failure"})}handleError(e){this.state.recordError(e,{type:e.type||"server-error",state:this.state.getState(),timestamp:(new Date).toISOString()});const t=this.messageHandlers.get("error");if(t){t({status:"error",error:this._getErrorMessage(e),details:{type:e.type||"server-error",state:this.state.getState(),timestamp:(new Date).toISOString()}})}}_getErrorMessage(e){return{network:"Network error - Could not connect to peer server","invalid-id":"Invalid ID - The peer ID is invalid or already taken","unavailable-id":"ID Unavailable - The peer ID is already taken","browser-incompatible":"Browser Incompatible - WebRTC is not supported","connection-failure":"Connection failed - Unable to establish or maintain connection",disconnected:"Disconnected - Lost connection to peer server"}[e.type]||e.message||"Peer connection error"}shouldAttemptReconnection(e){return!["browser-incompatible","invalid-id","invalid-key"].includes(e.type)&&this.state.getMetadata().metrics.reconnects.count<3}_setConnectionTimeout(){setTimeout((()=>{this.state.getState()!==o.STATES.CONNECTED&&(this.shouldAttemptReconnection({type:"timeout"})?this._handleReconnection({type:"timeout"}):this.handleError({type:"timeout",message:"Connection timeout - Max attempts reached"}))}),15e3)}async _handleReconnection(e){this.state.setState(o.STATES.RECONNECTING,{error:e.message,attempt:this.state.getMetadata().metrics.reconnects.count+1});const t=Math.min(2e3*Math.pow(1.5,this.state.getMetadata().metrics.reconnects.count),15e3),n=.2*t*(2*Math.random()-1),a=Math.max(2e3,t+n);await new Promise((e=>setTimeout(e,a))),this.state.getState()===o.STATES.RECONNECTING&&(await this._cleanup(!1),this.shouldAttemptReconnection(e)?(this.state.setState(o.STATES.CONNECTING),this.initialize()):this.state.setState(o.STATES.ERROR,{error:"Maximum reconnection attempts reached",type:"max_retries"}))}async _cleanup(e=!0){this.peer&&(this.peer.destroy(),this.peer=null),this.connection&&(this.connection.close(),this.connection=null),e&&(this.healthCheckInterval&&(clearInterval(this.healthCheckInterval),this.healthCheckInterval=null),this.pingInterval&&(clearInterval(this.pingInterval),this.pingInterval=null))}connect(){try{if(this.peer.connections[this.targetPeerId]?.length>0){const e=this.peer.connections[this.targetPeerId][0];if(e.open)return this.connection=e,void this.setupConnectionHandlers()}this.connection=this.peer.connect(this.targetPeerId,{reliable:!0,serialization:"binary"}),this.setupConnectionHandlers(),this._setConnectionTimeout()}catch(e){console.error("Error establishing connection:",e),this._handleReconnection(e)}}setupConnectionHandlers(){this.connection.on("open",(()=>{this.state.setState(o.STATES.CONNECTED,{peerId:this.targetPeerId,timestamp:new Date}),this.processMessageQueue();const e=this.messageHandlers.get("ready");e&&e({status:"connected",peerId:this.targetPeerId,state:this.state.getState(),timestamp:(new Date).toISOString()})})),this.connection.on("data",(e=>{if("pong"!==e.event)this.handleIncomingData(e);else{this.lastPingTime=Date.now();const t=Date.now()-e.data.timestamp;this.state.updateMetrics({latency:t})}})),this.connection.on("close",(()=>{this._isClosing||(this.state.setState(o.STATES.DISCONNECTED,{reason:"connection_closed"}),this._handleReconnection({type:"connection_closed"}))})),this.connection.on("error",(e=>{console.error("Data connection error:",e),this.state.setState(o.STATES.ERROR,{error:e.message,type:e.type}),this.handleError(e),this._handleReconnection(e)}))}handleIncomingData(e){try{const t=this.messageHandlers.get(e.event);if(t)t({...e.data,timestamp:Date.now(),state:this.state.getState()});else{const t=this.messageHandlers.get("data");t?t(e):console.warn("PeerConnection: No data handler found for event:",e.event)}}catch(e){console.error("Error handling incoming data:",e),this.handleError({type:"data_handling_error",message:"Error processing received data",originalError:e})}}async processMessageQueue(){for(;this.messageQueue.length>0&&this.state.getState()===o.STATES.CONNECTED;){const e=this.messageQueue.shift();try{await this.send(e.event,e.data)}catch(t){console.error("Failed to send queued message:",t),this.state.getState()===o.STATES.CONNECTED&&this.messageQueue.length<this.maxQueueSize&&this.messageQueue.push(e)}}}on(e,t){if("function"!=typeof t)throw new Error("Handler must be a function");this.messageHandlers.set(e,t)}async send(e,t){return new Promise(((n,a)=>{if(this.state.getState()===o.STATES.CONNECTED&&this.connection?.open)try{const s={event:e,data:t,timestamp:Date.now()},i=setTimeout((()=>{a(new Error("Send timeout"))}),5e3);this.connection.send(s),clearTimeout(i),n()}catch(e){a(e)}else this.messageQueue.length<this.maxQueueSize?(this.messageQueue.push({event:e,data:t}),n()):a(new Error("Message queue full"))}))}async close(){if(this._isClosing=!0,this.connection?.open)try{await this.send("shutdown",{reason:"client_close"})}catch(e){console.error("Error sending shutdown message:",e)}await this._cleanup(!0),this.state.reset(),this.messageQueue=[],this._isClosing=!1}isConnected(){return this.state.getState()===o.STATES.CONNECTED&&this.connection?.open}}function g(e,t){const n=e.imagedata||e.imageData;if(!e||!n)return void h("Invalid frame data received:",e);const{width:a,height:s}=n,i=document.createElement("canvas"),r=i.getContext("2d");i.width=a,i.height=s;try{if("string"==typeof n.data)d("Processing image data from data URL"),function(e,t,n,a,s){const i=document.createElement("canvas"),r=i.getContext("2d");i.width=t,i.height=n;const o=new Image;o.onload=()=>{r.drawImage(o,0,0,t,n),a(e)},o.onerror=e=>{s&&s(e)},o.src=e}(n.data,a,s,(i=>{t({src:i,width:a,height:s,raw:n,timestamp:e.timestamp||Date.now()})}),(i=>{c("Error loading image from data URL:",i),t({src:n.data,width:a,height:s,raw:n,timestamp:e.timestamp||Date.now()})}));else{d("Processing image data from raw pixel data");const o=u(n.data),c=new ImageData(o,a,s);r.putImageData(c,0,0);const h=i.toDataURL("image/jpeg");t({src:h,width:a,height:s,raw:n,timestamp:e.timestamp||Date.now()})}}catch(e){c("Error processing frame:",e),c("Frame data:",n)}}function u(e){return e instanceof Uint8ClampedArray?e:e instanceof Uint8Array||Array.isArray(e)?new Uint8ClampedArray(e):new Uint8ClampedArray(Object.values(e))}function p(e,t){return n=>{const a=n.data||n;l(`Frame handler for ${e} received:`,a);const s=a.imagedata||a.imageData;a.name===e&&s?(a.imageData&&!a.imagedata&&(a.imagedata=a.imageData),g(a,t)):h(`Received frame event but it's not a valid ${e} frame:`,"name=",a.name,"has imagedata=",!(!a.imagedata&&!a.imageData))}}class S{constructor(e){this.peer=new m(e),this.messageHandlers=new Map,this.state=null,this.peer.on("ready",(e=>{this.state=e.state;const t=this.messageHandlers.get("ready");t&&t(e)})),this.peer.on("error",(e=>{const t=this.messageHandlers.get("error");t&&t(e)})),this.peer.on("stateChange",(e=>{this.state=e.to;const t=this.messageHandlers.get("stateChange");t&&t(e)})),this.peer.on("metrics",(e=>{const t=this.messageHandlers.get("metrics");t&&t(e)})),this.peer.on("data",(e=>{const{event:t,data:n}=e,a=this.messageHandlers.get(t);a?a(n):h("Kinectron: No handler found for event:",t)}))}on(e,t){this.messageHandlers.set(e,t)}getState(){return this.peer.getState()}isConnected(){return this.state===o.STATES.CONNECTED}setKinectType(e){this.isConnected()?this.send("setkinect",e):h("Cannot set Kinect type: not connected")}initKinect(e){if(!this.isConnected())return h("Cannot initialize Kinect: not connected"),Promise.reject(new Error("Cannot initialize Kinect: not connected"));const t=new Promise(((e,t)=>{this.messageHandlers.set("kinectInitialized",(n=>{let a=!1;(n.success&&"object"==typeof n.success&&!0===n.success.success||"boolean"==typeof n.success&&!0===n.success)&&(a=!0);const s={success:a,alreadyInitialized:!!n.alreadyInitialized,error:n.error||null,rawData:n};a||n.alreadyInitialized?e(s):t(new Error(n.error||"Failed to initialize Kinect")),this.messageHandlers.delete("kinectInitialized")})),this.send("initkinect",{})}));return e&&t.then((t=>e(t))).catch((t=>e({success:!1,error:t.message}))),t}send(e,t){this.isConnected()?this.peer.send(e,t):h("Cannot send data: not connected")}startColor(e){e&&this.messageHandlers.set("frame",p("color",e)),this.send("feed",{feed:"color"})}startDepth(e){e&&this.messageHandlers.set("frame",p("depth",e)),this.send("feed",{feed:"depth"})}_unpackRawDepthData(e,t,n,a,s){return new Promise(((a,s)=>{const i=new Image;i.onload=()=>{const e=new OffscreenCanvas(t,n).getContext("2d");e.drawImage(i,0,0);const s=e.getImageData(0,0,t,n).data,r=new Uint16Array(t*n);let o=0;for(let e=0;e<s.length;e+=4){const t=s[e+1]<<8|s[e];r[o++]=t}a(r)},i.onerror=e=>{s(new Error("Failed to load depth image: "+e))},i.src=e}))}startRawDepth(e){e&&this.messageHandlers.set("rawDepth",function(e,t){return n=>{n&&n.imagedata?t(n.imagedata,n.width,n.height,n.width,n.testValues).then((t=>{e({...n,depthValues:t,timestamp:n.timestamp||Date.now()})})).catch((t=>{c("Error unpacking raw depth data:",t),e({...n,error:"Failed to unpack depth data: "+t.message,timestamp:n.timestamp||Date.now()})})):n&&n.rawDepthData?e({...n,timestamp:n.timestamp||Date.now()}):(h("Received raw depth frame with invalid data format:",n),e({...n,error:"Invalid data format",timestamp:n.timestamp||Date.now()}))}}(e,this._unpackRawDepthData.bind(this))),this.send("feed",{feed:"raw-depth"})}startBodies(e){e&&this.messageHandlers.set("bodyFrame",function(e){return l("Creating body handler with callback:",e),t=>{const n=t.data;n&&n.bodies&&e({bodies:n.bodies,timestamp:n.timestamp||Date.now(),floorClipPlane:n.floorClipPlane,trackingId:n.trackingId})}}(e)),this.send("feed",{feed:"body"})}startKey(e){e&&this.messageHandlers.set("frame",p("key",e)),this.send("feed",{feed:"key"})}startDepthKey(e){e&&this.messageHandlers.set("depth-key",p("depth-key",e)),this.send("feed",{feed:"depth-key"})}startRGBD(e){e&&this.messageHandlers.set("frame",p("rgbd",e)),this.send("feed",{feed:"rgbd"})}startMultiFrame(e,t){t&&this.messageHandlers.set("multiFrame",function(e){return t=>{if(t&&t.frames){const n={};Object.entries(t.frames).forEach((([e,t])=>{if(t.imagedata){const a=document.createElement("canvas"),s=a.getContext("2d"),{width:i,height:r}=t.imagedata;a.width=i,a.height=r;const o=new ImageData(u(t.imagedata.data),i,r);s.putImageData(o,0,0),n[e]={src:a.toDataURL("image/jpeg"),width:i,height:r,raw:t.imagedata}}else n[e]=t})),e({frames:n,timestamp:t.timestamp||Date.now()})}}}(t)),this.send("multi",e)}stopAll(){this.send("feed",{feed:"stop-all"})}close(){this.peer.close(),this.messageHandlers.clear(),this.state=null}}console.log("You are running Kinectron API version 1.0.0");export{S as default};
//# sourceMappingURL=kinectron.esm.js.map
